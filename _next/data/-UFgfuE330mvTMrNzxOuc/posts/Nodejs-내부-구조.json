{"pageProps":{"frontMatter":{"title":"Node.js 내부 구조","description":"Node.js 내부 구조에 대해서 알아보기","uploaded":"2022-03-03","updated":"2022-03-03","tags":["node.js"],"draft":false},"slug":"Nodejs-내부-구조","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      code: \"code\",\n      h4: \"h4\",\n      strong: \"strong\",\n      blockquote: \"blockquote\",\n      a: \"a\",\n      h3: \"h3\",\n      h5: \"h5\",\n      pre: \"pre\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"Node.js?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Node.js는 JavaScript엔진 중 하나인 Google Chrome V8엔진을 이용해 JavaScript를 브라우저 밖에서 실행 가능하게 해주는 JS Runtime Environment이다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Node.js는 V8엔진을 이용해 JS를 해석한다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"브라우저에서 돌아가지 않기 때문에 \", _jsx(_components.code, {\n            children: \"window\"\n          }), \"나 \", _jsx(_components.code, {\n            children: \"document\"\n          }), \"같은 Web API는 사용할 수 없다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"OS위에서 돌아가기 때문에 \", _jsx(_components.code, {\n            children: \"fs\"\n          }), \", \", _jsx(_components.code, {\n            children: \"http\"\n          }), \"가 standard library로 제공된다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"node.js는 V8엔진이 지원하는 기능만 쓸 수 있기 때문에, 모든 JS 기능을 바로 쓰지 못할 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"JavaScript Engine?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"JavaScript 엔진은 변수, 함수 객체를 저장하는 \", _jsx(_components.strong, {\n          children: \"Memory Heap\"\n        }), \"과 함수 호출에 쓰이는 \", _jsx(_components.strong, {\n          children: \"Call Stack\"\n        }), \"을 가지고 있으며, JavaScript 코드를 실행하기 위해 machine 코드로 변환하거나 Garbage Collection 등등을 수행한다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"브라우저는 각자 내장된 JS엔진을 사용해 웹 페이지의 JS코드를 해석하는데 브라우저마다 다른 엔진을 사용해 언어를 해석하기 때문에 같은 코드여도 브라우저마다 다른 결과가 나올 수 있다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Node.js 계층 구조\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Node.js API\"\n          }), \" : Node.js Application에 쓰이는 JS API\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Node.js Standard library\"\n          }), \" : OS관련 함수들이 포함된다(Timer \", _jsx(_components.code, {\n            children: \"setTimeout\"\n          }), \", File System \", _jsx(_components.code, {\n            children: \"fs\"\n          }), \", Network Calls \", _jsx(_components.code, {\n            children: \"http\"\n          }), \")\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"V8\"\n          }), \" : Memory Heap, Call Stack, Garbage Collector로 구성된다 + JS를 OS에 맞는 machine code로 변환한다\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"libuv\"\n          }), \" : 비동기 I/O를 지원하는 C언어 library로, 커널의 비동기 API(윈도우- IOCP, 리눅스-AIO)로 지원할 수 없는 작업을 비동기화 하기 위한 \", _jsx(_components.strong, {\n            children: \"별도의 Thread Pool\"\n          }), \"(기본 값으로 4개를 사용하도록 설정되어 있음)을 가지고 있고 Event Loop, Event Queue를 관리한다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"c-ares\"\n          }), \" : \", _jsx(_components.code, {\n            children: \"dns\"\n          }), \"모듈에 쓰이는 비동기 DNS 요청을 위한 C언어 library\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"llhttp\"\n          }), \" : HTTP requeset/response 파싱 (이전엔 \", _jsx(_components.code, {\n            children: \"http-parsed\"\n          }), \"가 쓰였다)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"open-ssl\"\n          }), \" : 암호화 library (\", _jsx(_components.code, {\n            children: \"tls\"\n          }), \", \", _jsx(_components.code, {\n            children: \"crypto\"\n          }), \"모듈에 쓰인다)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"zlib\"\n          }), \" : 압축/압축 해제 library\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Node.js dependencies: \", _jsx(_components.a, {\n            href: \"https://nodejs.org/en/docs/meta/topics/dependencies/\",\n            children: \"Dependencies | Node.js (nodejs.org)\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Node.js 특징\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Single Threaded\"\n          }), \" - locking이 없으므로 프로그램이 덜 복잡해진다\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Non-Blocking I/O\"\n          }), \" - I/O가 끝날 때까지 기다리지 않는다\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Asynchronous\"\n          }), \" - 비동기로 실행한다\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"💡 Single thread임에도 Asynchronous Non-Blocking I/O가 가능한 이유는 Event Loop때문이다.\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Event loop에서 각 요청에 맞는 kernel의 비동기 함수를 호출하거나, kernel 비동기 함수로 지원되지 않는 작업은 libuv의 thread pool을 이용해 별도의 스레드를 만들어 처리한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"main thread가 아닌 백그라운드에서 여러 작업을 수행할 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"💡 Multi-thread가 아니기 때문에 CPU를 많이 사용하는 작업에는 적합하지 않고, I/O가 많은 작업에 사용하는 것이 적합하다\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Event Loop\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/nodejs-event-loop.png\",\n        alt: \"nodejs event loop workflow\",\n        sourceHref: \"https://www.voidcanvas.com/nodejs-event-loop/\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.code, {\n              children: \"node main.js\"\n            }), \"를 콘솔에서 실행시켰을 때, Node.js는 이벤트 루프를 생성한 다음 \", _jsx(_components.strong, {\n              children: \"이벤트 루프 바깥\"\n            }), \"에서 메인 모듈인 \", _jsx(_components.code, {\n              children: \"main.js\"\n            }), \"를 실행한다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"한번 메인 모듈이 실행되고나면 Node.js는 이벤트 루프가 활성 상태인지, 즉 이벤트 루프 안에서 해야할 작업이 있는지를 확인한다. 만약 이벤트 루프를 돌릴 필요가 없다면 종료한다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"이벤트 루프를 돌려야 한다면 Timer 단계부터 실행된다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"육각형이 이벤트 루프의 각 단계를 말하고, 각 단계는 실행할 callback들을 담은 FIFO Queue를 가진다\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"내부의 \", _jsx(_components.code, {\n                children: \"nextTickQueue\"\n              }), \", \", _jsx(_components.code, {\n                children: \"microTaskQueue\"\n              }), \" 는 이벤트 루프의 일부가 아니며 어떤 단계에서든 실행될 수 있고, 가장 높은 우선순위를 지닌다.\"]\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \"nextTickQueue\"\n              }), \"에 담긴 작업이 재귀 호출을 수행하는 경우 Node.js의 작업 프로세스를 블록킹할 수 있다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"이벤트 루프가 해당 단계에 진입하면 해당 단계에 한정된 작업을 수행하고, 큐를 모두 소진하거나 최대 개수의 콜백을 실행할때 까지 콜백을 실행한다. (큐를 모두 소진하거나 콜백 제한에 걸리면 다음 단계로 이동)\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Call Stack이 비어있으면 이벤트 루프는 큐에서 I/O가 끝난 작업의 콜백을 Call Stack에 넘겨서 실행될 수 있게 한다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"이벤트 루프는 루프마다 다른 비동기 I/O나 Timer를 기다려야 하는지 확인하고 기다리는 것이 없다면 깔끔하게 종료한다.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"각 단계\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"timers\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"setTimeout()\"\n        }), \"과 \", _jsx(_components.code, {\n          children: \"setInterval()\"\n        }), \"로 스케줄링한 콜백을 실행한다. (min-heap으로 타이머들을 유지한다)\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"타이머 콜백은 지정한 시간이 지난 후에 스케줄링 될 수 있는 가장 이른시간에 실행된다. (운영체제 스케줄링이나 다른 콜백 실행때문에 지연될 수 있다)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"*기술적으로는 poll 단계에서 타이머를 언제 실행할지 제어한다. (poll 큐에 이벤트가 없어야 Timer를 확인한다)\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"pending callbacks\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"TCP 오류 같은 시스템 작업의 콜백을 실행한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"ex. 에러 핸들러 콜백\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"idle, prepare\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"내부용으로만 사용한다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"poll\"\n        })\n      }), \"\\n\", _jsx(_components.h5, {\n        children: _jsx(_components.strong, {\n          children: \"두 가지 주요 기능\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"I/O를 얼마나 오래 block하고 polling하는 지 계산한다\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"그 다음 poll 큐에 있는 이벤트를 처리한다\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"I/O와 연관된 콜백(close callback, Timer callback, \", _jsx(_components.code, {\n                children: \"setImmediate()\"\n              }), \"를 제외한 거의 모든 콜백이 포함된다)\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"만약 이벤트 루프가 이 단계에 진입하고, \", _jsx(_components.strong, {\n          children: \"스케줄링된 타이머가 없을때\"\n        }), \" 두 가지 상황 중 하나가 발생한다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Poll 큐가 \", _jsx(_components.strong, {\n            children: \"비어있지 않다면\"\n          }), \" 이벤트 루프가 콜백의 큐를 순회하면서 큐를 다 소진하거나, 시스템에 의존적인 하드 한계에 도달할 때까지 동기로 콜백을 실행한다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Poll 큐가 \", _jsx(_components.strong, {\n            children: \"비어있다면\"\n          }), \" 다음 중 하나의 상황이 발생한다.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"setImmediate()가 스케줄링되었다면 이벤트 루프는 poll단계를 종료하고 스케줄링된 스크립트를 실행하기 위해 check단계로 넘어간다\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"setImmediate()가 스케줄링되지 않았다면 이벤트 루프는 콜백이 Poll 큐에 추가되기를 기다린 후 즉시 실행한다\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"+) 단, poll 큐가 일단 비게 되면 타이머가 \", _jsx(_components.strong, {\n          children: \"시간을 초과했는지\"\n        }), \" 확인하고, 하나 이상의 타이머가 준비되었다면 이벤트 루프는 타이머의 콜백을 실행하기 위해 timers단계로 돌아간다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"+) 폴링 이벤트를 처리하면서 poll 이벤트를 큐에 추가할 수 있다. 그 결과 오래 실행되는 콜백은 poll 단계가 타이머의 한계 시점보다 훨씬 더 오래 실행되도록 할 수 있다. (단, poll 단계가 이벤트 루프를 모두 차지하면 안되므로 libuv는 최대치를 설정한다)\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"check\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"setImmediate()\"\n        }), \" 콜백을 호출한다.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"close callbacks\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"socket.on('close', ...)\"\n        }), \"같은 close 이벤트 타입의 핸들러들을 처리한다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"setImmediate() vs setTimeout() vs process.nextTick() 실행 순서\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"setImmediate() vs setTimeout()\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"비슷하지만 호출된 시기에 따라 다르게 동작한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Example 1\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"setTimeout(() => {\\n  console.log('setTimeout');\\n}, 0);\\nsetImmediate(() => {\\n  console.log('setImmediate');\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"▲ 뭐가 먼저 출력되는 지 알 수 없다. 이벤트 루프가 Timer 단계에 진입할 때 타이머가 등록되지 않을 수 있기 때문이다(타이머는 메모리에 저장되는데, 그 순간 컴퓨터의 성능이나 Node.js가 아닌 외부 작업 때문에 약간의 딜레이가 발생할 수 있다)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Example 2\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"fs.readFile('my-file-path.txt', () => {\\n  setTimeout(() => {\\n    console.log('setTimeout');\\n  }, 0);\\n  setImmediate(() => {\\n    console.log('setImmediate');\\n  });\\n});\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"▲ I/O 주기 내에서 호출하면 \", _jsx(_components.code, {\n          children: \"setImmediate\"\n        }), \"가 항상 먼저 실행된다. (poll 이후에 바로 check단계에서 setImmediate가 실행되므로. setTimeout은 그 다음 루프의 timers에서 실행된다)\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"setImmediate() vs process.nextTick()\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"process.nextTick()이 setImmediate()보다 더 즉시 실행된다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"process.nextTick(): 한 단계에서 다음 단계로 넘어가는 매 \", _jsx(_components.code, {\n            children: \"tick\"\n          }), \"마다 최대한 빨리 호출되도록 작동된다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"setImmediate(): 루프가 돌때마다 관리한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"참고 자료\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/\",\n            children: \"Node.js 이벤트 루프, 타이머, `process.nextTick()` | Node.js (nodejs.org)\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://www.voidcanvas.com/nodejs-event-loop/\",\n            children: \"Node.js event loop workflow & lifecycle in low level (voidcanvas.com)\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://medium.com/zigbang/nodejs-event-loop%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-16e9290f2b30\",\n            children: \"NodeJS Event Loop파헤치기\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://chathuranga94.medium.com/nodejs-architecture-concurrency-model-f71da5f53d1d\",\n            children: \"NodeJS Architecture & Concurrency Model | by Udara Bibile | Medium\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/\",\n            children: \"로우 레벨로 살펴보는 Node.js 이벤트 루프 | Evans Library (evan-moon.github.io)\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}