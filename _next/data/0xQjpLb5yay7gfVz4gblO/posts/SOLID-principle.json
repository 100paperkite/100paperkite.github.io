{"pageProps":{"frontMatter":{"title":"SOLID 원칙","description":null,"uploaded":"2022-12-14","updated":null,"tags":["OOP"],"draft":false},"slug":"SOLID-principle","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      code: \"code\",\n      h3: \"h3\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"SOLID 원칙이란?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"클린 코드\"\n        }), \" 저자인 로버트 마틴이 정리한 객체 지향 프로그래밍 원칙. 좋은 객체 지향 설계를 위해선 이 원칙들을 따라야 한다.\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"1. \", _jsx(_components.strong, {\n          children: \"SRP\"\n        }), \"(Single Responsiblity Principle) \", _jsx(\"small\", {\n          children: \": 단일 책임 원칙\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"하나의 클래스는 하나의 책임을 따라야 한다 (클래스의 관심사가 하나인 것)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"변경이 일어났을 때 변경이 일어난 부분만 바뀌어야 한다 (파급 효과가 적어야 한다)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"2. \", _jsx(_components.strong, {\n          children: \"OCP\"\n        }), \"(Open/Closed Principle) \", _jsx(\"small\", {\n          children: \": 개방-폐쇄 원칙\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"확장에는 열려있지만 변경에는 닫혀있어야 한다. - \", _jsx(_components.strong, {\n            children: \"다형성\"\n          })]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"역할과 구현을 분리하는 것으로 생각하면 된다. (구현으로 확장이 가능하지만, 인터페이스가 변하지 않는 한 다른 곳에 변경은 없음)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"구현 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 대신 필요하게 된다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"3. \", _jsx(_components.strong, {\n          children: \"LSP\"\n        }), \"(Liskov Substitution Principle) \", _jsx(\"small\", {\n          children: \": 리스코프 치환 원칙\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"다형성에서 인터페이스를 구현한 구현체는 인터페이스의 규약을 다 지켜야 한다는 의미이다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"4. \", _jsx(_components.strong, {\n          children: \"ISP\"\n        }), \"(Interface Segregation Principle)\", _jsx(\"small\", {\n          children: \": 인터페이스 분리 원칙\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"범용 인터페이스 하나 보다 특정 클라이언트를 위한 인터페이스 여러 개가 낫다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"분리하면 인터페이스가 명확해지고, 대체 가능성이 높아진다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"5. \", _jsx(_components.strong, {\n          children: \"DIP\"\n        }), \"(Dependency Inverstion Principle)\", _jsx(\"small\", {\n          children: \": 의존관계 역전 원칙\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"구현 클래스에 의존하지 말고 인터페이스에 의존해야 하는것.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"구현체에 의존하면 변경이 어려워지게 된다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"의존성 주입\"\n          }), \"은 이 원칙을 따르는 방법 중 하나. 추상화인 인터페이스에 의존하므로, 생성자로 구현체를 갈아끼울 수 있다.\"]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}