{"pageProps":{"frontMatter":{"title":"[자바 스터디] 3주차 정리","description":null,"uploaded":"2023-01-19","updated":null,"tags":["study-halle","java"],"draft":false},"slug":"java-study-halle-3rd-week","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      hr: \"hr\",\n      pre: \"pre\",\n      code: \"code\",\n      table: \"table\",\n      thead: \"thead\",\n      tr: \"tr\",\n      th: \"th\",\n      tbody: \"tbody\",\n      td: \"td\",\n      a: \"a\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(Image, {\n        src: \"/study-halle.jpeg\",\n        alt: \"study halle image\",\n        height: \"400px\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"목표\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"자바가 제공하는 다양한 연산자를 학습.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"학습할 것\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"산술 연산자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"비트 연산자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"관계 연산자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"논리 연산자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"instanceof\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"assignment(=) operator\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"화살표(->) 연산자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"3항 연산자\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"연산자 우선 순위\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"(optional) Java 13. switch 연산자\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"+) 자바의 연산자 평가 순서\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"int a = 2;\\nint v = ++a + ++a * ++a;\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"인터프리터는 항상 연산자를 왼쪽 → 오른쪽으로 평가한다. 따라서 위 코드에서 \", _jsx(_components.code, {\n          children: \"*\"\n        }), \" 곱셈이 \", _jsx(_components.code, {\n          children: \"+\"\n        }), \" 덧셈보다 먼저 수행될지라도, \", _jsx(_components.code, {\n          children: \"+\"\n        }), \" 연산자는 먼저 평가되어 v는 \", _jsx(_components.code, {\n          children: \"3 + 4 * 5\"\n        }), \" 인 \", _jsx(_components.code, {\n          children: \"23\"\n        }), \" 이 된다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"산술 연산자\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"덧셈 \", _jsx(_components.code, {\n            children: \"+\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"String concatenation operator 로도 동작한다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"Java는 모든 primitive type에 대해 string 변환을 제공하기 때문에 “Hello” + 123 : “Hello 123” 이 된다.\"\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \"toString()\"\n              }), \" 을 정의한 클래스는 해당 메서드가 실행된다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"빼기 \", _jsx(_components.code, {\n            children: \"-\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"곱셈 \", _jsx(_components.code, {\n            children: \"*\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"나눗셈 \", _jsx(_components.code, {\n            children: \"/\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"modulo \", _jsx(_components.code, {\n            children: \"%\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"floating-point에도 동작한다. ex) \", _jsx(_components.code, {\n                children: \"4.3 % 2.1\"\n              }), \"은 0.1\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"비교 연산자\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"==\"\n          }), \" , \", _jsx(_components.code, {\n            children: \"!=\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \"NaN\"\n              }), \" 은 어떤 값과도 같지 않음.\"]\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"positive zero와 negative zero는 같은 것으로 친다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"<\"\n          }), \" \", _jsx(_components.code, {\n            children: \">\"\n          }), \" \", _jsx(_components.code, {\n            children: \"<=\"\n          }), \" \", _jsx(_components.code, {\n            children: \">=\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"논리 연산자\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"&&\"\n          }), \" and\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"||\"\n          }), \" or\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"!\"\n          }), \" not\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"&\"\n          }), \" and (비트 연산에도 사용. \", _jsx(_components.code, {\n            children: \"&&\"\n          }), \" 와는 달리 피연산자 두 개의 값을 전부 확인한다)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"|\"\n          }), \" or (비트 연산에도 사용. \", _jsx(_components.code, {\n            children: \"||\"\n          }), \" 와는 달리 피연산자 두 개의 값을 전부 확인한다)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"^\"\n          }), \" xor (비트 연산에도 사용)\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"비트 연산자\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"~\"\n          }), \" not\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"&\"\n          }), \" and\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"|\"\n          }), \" or\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"^\"\n          }), \" xor\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"<<\"\n          }), \" left shift\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \">>\"\n          }), \" right shift\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \">>>\"\n          }), \" unsigned right shift\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \">>\"\n              }), \" 는 MSB 부호를 그대로 유지하면서 옮기는 반면, \", _jsx(_components.code, {\n                children: \">>>\"\n              }), \" 는 항상 0으로 채운다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"instanceof\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"타입을 확인하는 연산자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"// True: 모든 문자열은 String 클래스의 인스턴스이다.\\n\\\"string\\\" instanceof String\\n// True: 모든 문자열은 Object 클래스의 인스턴스이다.\\n\\\"\\\" instanceof Object\\n// False: null은 어떤 것의 인스턴스도 아니다.\\nnull instanceof String\\n\\nObject o = new int[] {1,2,3};\\no instanceof int[]   // True\\no instanceof byte[]  // False : byte 배열이 아니다.\\no instanceof Object  // True: 모든 배열은 Object의 인스턴스이다.\\n\\n// 안전한 타입 캐스팅을 위해서는 instanceof로 확인하자.\\nif (object instanceof Point) {\\n   Point p = (Point) object;\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"assignment(=) operator\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"값을 저장(=할당)할 때 쓴다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"오른쪽 → 왼쪽 순서대로 할당된다 \", _jsx(_components.code, {\n            children: \"a=b=c\"\n          }), \" ←→ \", _jsx(_components.code, {\n            children: \"a=(b=c)\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"화살표(->) 연산자\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Lambda식의 표현을 위한 연산자.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"3항 연산자\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"if else\"\n        }), \" 문을 한 줄의 표현식으로 만든것 → \", _jsx(_components.code, {\n          children: \"<condition> ? <if true> : <if false>\"\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"연산자 우선 순위\"\n      }), \"\\n\", _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Operators\"\n            }), _jsx(_components.th, {\n              children: \"Precedence\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"postfix increment and decrement\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"++\"\n              }), \" \", _jsx(_components.code, {\n                children: \"--\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"prefix increment and decrement, and unary\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"++\"\n              }), \" \", _jsx(_components.code, {\n                children: \"--\"\n              }), \" \", _jsx(_components.code, {\n                children: \"+\"\n              }), \" \", _jsx(_components.code, {\n                children: \"-\"\n              }), \" \", _jsx(_components.code, {\n                children: \"~\"\n              }), \" \", _jsx(_components.code, {\n                children: \"!\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"multiplicative\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"*\"\n              }), \" \", _jsx(_components.code, {\n                children: \"/\"\n              }), \" \", _jsx(_components.code, {\n                children: \"%\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"additive\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"+\"\n              }), \" \", _jsx(_components.code, {\n                children: \"-\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"shift\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"<<\"\n              }), \" \", _jsx(_components.code, {\n                children: \">>\"\n              }), \" \", _jsx(_components.code, {\n                children: \">>>\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"relational\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"<\"\n              }), \" \", _jsx(_components.code, {\n                children: \">\"\n              }), \" \", _jsx(_components.code, {\n                children: \"<=\"\n              }), \" \", _jsx(_components.code, {\n                children: \">=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"instanceof\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"equality\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"==\"\n              }), \" \", _jsx(_components.code, {\n                children: \"!=\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"bitwise AND\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"&\"\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"bitwise exclusive OR\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"^\"\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"bitwise inclusive OR\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"|\"\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"logical AND\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"&&\"\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"logical OR\"\n            }), _jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"||\"\n              })\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"ternary\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"?\"\n              }), \" \", _jsx(_components.code, {\n                children: \":\"\n              })]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"assignment\"\n            }), _jsxs(_components.td, {\n              children: [_jsx(_components.code, {\n                children: \"=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"+=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"-=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"*=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"/=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"%=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"&=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"^=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"|=\"\n              }), \" \", _jsx(_components.code, {\n                children: \"<<=\"\n              }), \" \", _jsx(_components.code, {\n                children: \">>=\"\n              }), \" \", _jsx(_components.code, {\n                children: \">>>=\"\n              })]\n            })]\n          })]\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Java 13. switch 연산자\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"참고 - \", _jsx(_components.a, {\n          href: \"https://openjdk.org/jeps/354\",\n          children: \"https://openjdk.org/jeps/354\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"switch\"\n          }), \" 구문을 표현식으로 쓸 수 있다 (값 형태로 사용가능)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"case L:\"\n          }), \" 형태의 구문을 \", _jsx(_components.code, {\n            children: \"case L ->\"\n          }), \" 구문으로 변경해서 쓸 수 있다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"// 기존 switch 구문(다른 언어들과 형태가 비슷). 코드가 장황해지기 쉽다.\\nswitch (day) {\\n    case MONDAY:\\n    case FRIDAY:\\n    case SUNDAY:\\n        System.out.println(6);\\n        break;\\n    case TUESDAY:\\n        System.out.println(7);\\n        break;\\n    case THURSDAY:\\n    case SATURDAY:\\n        System.out.println(8);\\n        break;\\n    case WEDNESDAY:\\n        System.out.println(9);\\n        break;\\n}\\n\\n// 바뀐 `->` 구문. case 내부에 선언된 변수의 scope를 case 안으로 제한한다.\\nswitch (day) {\\n    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);\\n    case TUESDAY                -> System.out.println(7);\\n    case THURSDAY, SATURDAY     -> System.out.println(8);\\n    case WEDNESDAY              -> System.out.println(9);\\n}\\n\\n// 여러 줄로 쓰려면 `yield`키워드를 사용한다.\\nint result = switch (s) {\\n    case \\\"Foo\\\":\\n        yield 1;\\n    case \\\"Bar\\\":\\n        yield 2;\\n    default:\\n        System.out.println(\\\"Neither Foo nor Bar, hmmm...\\\");\\n        yield 0;\\n};\\n\\n// 표현식\\nint numLetters = switch (day) {\\n    case MONDAY, FRIDAY, SUNDAY -> 6;\\n    case TUESDAY                -> 7;\\n    case THURSDAY, SATURDAY     -> 8;\\n    case WEDNESDAY              -> 9;\\n};\\n\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"참고\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://learning.oreilly.com/library/view/java-in-a/9781492037248/\",\n            children: \"[Book] Java in a Nutshell 7th Edition\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://youtube.com/playlist?list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU\",\n            children: \"Study Halle\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}