{"pageProps":{"frontMatter":{"title":"Redux","description":null,"uploaded":"2022-04-25T14:07:00.131Z","updated":"2022-04-25T14:07:00.131Z","tags":["react","frontend","redux"],"draft":false},"slug":"Redux","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      h2: \"h2\",\n      h3: \"h3\",\n      pre: \"pre\",\n      a: \"a\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"컴포넌트 간의 상태(cross-component)\"\n        }), \" 또는 \", _jsx(_components.code, {\n          children: \"앱 전반에 걸친 상태(app-wide)\"\n        }), \"를 위한 third party 상태 관리 시스템.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"React Context의 단점\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"1. 관리의 어려움\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"대규모 어플리케이션에선 React Context를 사용하면 마치 js의 콜백 지옥 처럼 아래와 같이 관리가 복잡해진다. 그렇다고 하나의 Context만 쓴다면 해당 컴포넌트에서 모든 상태를 관리하게 되므로 Context 컴포넌트가 무거워지고 또 관리가 어렵다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-jsx\",\n          children: \"return (\\n  <AAAContextProvider>\\n    <BBBContextProvider>\\n      <CCCContextProvider>{/* 점점 깊어진다 */}</CCCContextProvider>\\n    </BBBContextProvider>\\n  </AAAContextProvider>\\n);\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"2. 성능의 한계\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"리액트 개발자의 \", _jsx(_components.a, {\n          href: \"https://github.com/facebook/react/issues/14110#issuecomment-448074060\",\n          children: \"GitHub 코멘트\"\n        }), \"를 보면, 애초에 Context API는 자주 변경되는 상태 관리에 적합하지 않다고 한다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Redux 동작 방식\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"중앙 데이터 저장소를 가진다. (어플리케이션 당 단 하나의 저장소만 존재한다.)\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.a, {\n            href: \"https://ko.wikipedia.org/wiki/%EB%B0%9C%ED%96%89-%EA%B5%AC%EB%8F%85_%EB%AA%A8%EB%8D%B8\",\n            children: \"발행-구독 모델\"\n          }), \"을 따른다.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"컴포넌트가 저장소를 구독한다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"상태를 변경하기 위한 action 을 dispatch 하면 reducer 함수가 실행되고, action에 따라 저장소의 상태를 변경한다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"상태가 변경되면 저장소는 구독중인 컴포넌트에 최신 상태를 전달한다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"코드 예시\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"\\nconst INCREMENT = 'INCREMENT';\\nconst DECREMENT = 'DECREMENT';\\n\\n\\nimport { createStore } from 'redux';\\n\\n// 상태를 관리하는 함수\\nconst counterReducer = (state = { count: 0 }, action) => {\\n    if (action.type === INCREMENT) {\\n        return {\\n            count: state + action.amount;\\n        };\\n    }\\n    else if (action.type == DECREMENT) {\\n        return {\\n            count: state - action.amount;\\n        };\\n    }\\n    return state;\\n}\\n\\n// 상태 저장소 생성\\nconst store = createStore(counterReducer);\\n\\n// 현재 상태를 출력하는 구독 함수\\nconst counterSubscriber = () => {\\n    console.log(store.getState());\\n}\\n\\n// 저장소가 해당 함수를 구독한다. (상태가 변경되면 해당 함수가 실행된다.)\\nstore.subscribe(counterSubscriber);\\n\\n// 상태를 변경. counterSubscriber가 실행되고 { count: 1 } 가 출력된다.\\nstore.dispatch({ type: INCREMENT, amount: 1});\\n\\n// 상태를 변경. counterSubscriber가 실행되고 { count: 0 } 가 출력된다.\\nstore.dispatch({ type: DECREMENT, amount: 1});\\n\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"React에서 redux 사용하기\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"// store.js\\n\\n// 이전 코드는 생략...\\nstore = createStore(counterReducer);\\n\\nexport default store;\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-JSX\",\n          children: \"// App.jsx\\nimport { Provider } from 'react-redux';\\nimport Counter from './components/Counter';\\n\\nconst App = () => {\\n  return (\\n    <Provider store={store}>\\n      <Counter />\\n    </Provider>\\n  );\\n};\\n\\n// Counter.jsx\\nimport { INCREMENT, DECREMENT } from './store';\\nimport { useSelector, useDispatch } from 'react-redux';\\n\\nconst Counter = () => {\\n  const dispatch = useDispatch();\\n  // 상태의 일부를 반환. useSelector hook이 해당 컴포넌트를 자동으로 구독하므로 상태가 변경되면 자동으로 반영된다.\\n  const count = useSelector((state) => state.count);\\n\\n  return (\\n    <div>\\n      <h1>{count}</h1>\\n      <button onClick={() => dispatch({ type: INCREMENT, amount: 1 })}>+</button>\\n      <button onClick={() => dispatch({ type: DECREMENT, amount: 1 })}>-</button>\\n    </div>\\n  );\\n};\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Redux toolkit\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"redux를 좀 더 쉽게 사용하기 위한 툴킷.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"// store.js\\nconst { createStore } from 'redux';\\nconst { createSlice, configureStore } from '@reduxjs/toolkit';\\n\\nconst initialState = {\\n  count: 0,\\n};\\n\\nconst counterSlice = createSlice({\\n    name: 'counter',\\n    initialState, // 초기 값\\n    reducers: {\\n        // 여기에 action에 따라 동작할 함수를 정의한다.\\n        increment(state, action) {\\n            /**\\n             *  action에는 redux-toolkit이 자동으로 생성한 action 객체가 전달된다.\\n             *  { type: 'redux toolkit이 생성한 고유한 ID 값', payload: ... }\\n             */\\n\\n            // 기존과 달리 상태 객체의 상태를 직접 참조해서 변경해도 문제가 없다. 내부에서 따로 상태를 복제해서 사용.\\n            state.count = state.count + action.payload;\\n        }\\n        decrement(state, action) {\\n            state.count = state.count - action.payload;\\n        }\\n    }\\n})\\n\\nconst store = configureStore({\\n    reducer: {\\n        counter: counterSlice.reducer, // reducer map을 만듦\\n        // 여기에도 다른 슬라이스를 추가할 수 있다.\\n    }\\n});\\n\\nexport const counterActions = counterSlice.actions;\\n\\n\\n// Counter.jsx\\nimport { useSelector, useDispatch } from 'react-redux';\\nimport { counterActions } from './store';\\n\\nconst Counter = () => {\\n  const dispatch = useDispatch();\\n  const count = useSelector((state) => state.counter.count);\\n\\n  return (\\n    <div>\\n      <h1>{count}</h1>\\n      <button onClick={() => dispatch(counterActions.increment(1))}>+</button>\\n      <button onClick={() => dispatch(counterActions.decrement(1))}>-</button>\\n    </div>\\n  );\\n};\\n\\n\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}