{"pageProps":{"frontMatter":{"title":"JVM(Java Virtual Machine)","description":null,"uploaded":"2023-01-08","updated":null,"tags":["java","jvm"],"draft":false},"slug":"how-jvm-works","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      h3: \"h3\",\n      h4: \"h4\",\n      ol: \"ol\",\n      code: \"code\",\n      strong: \"strong\",\n      a: \"a\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"가상 머신(Virtual Machine)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"안에서 돌아가는 소프트웨어가 가상머신이 제공하는 환경과 자원에 제한을 받으며 가상 환경을 벗어날 수 없다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"System Virtual Machine\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"완전한 OS 실행을 지원.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"같은 컴퓨터 내에서 여러 운영체제를 돌릴 수 있다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Process Virtual Machine\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"단일 프로세스를 지원\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"플랫폼에 독립적인 실행환경과 추상화를 제공하여 하나의 프로그램을 실행한다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"JVM이 이런 경우다. (C#의 CLR도 마찬가지)\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"JVM?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"JVM은 명세이다. 이 명세를 따른 구현체들이 따로 존재한다. (HotSpot VM 등등)\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"JVM Architecture\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Java로 작성된 코드는 Compiler가 바이트 코드(.class 파일) 로 변환하고, JRE에 속한 JVM이 이 바이트 코드를 JIT 컴파일하여 실행된다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"JDK (Java Development Kit)\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"JRE를 포함하며, 개발을 위한 컴파일러나 디버거도 같이 제공된다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"JRE (Java Runtime Environment)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"구성 요소\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/jvm-architecture.png\",\n        alt: \"jvm architecture\",\n        height: \"360px\",\n        sourceHref: \"https://www.freecodecamp.org\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Class Loader\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/jvm-class-loader.png\",\n        alt: \"jvm class loader\",\n        height: \"300px\",\n        sourceHref: \"https://www.freecodecamp.org\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Loading\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"1. 클래스 정보를 읽어온다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"‘.class’ 파일을 읽으면, 관련된 바이너리 데이터를 생성하고 이를 method area에 저장한다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"method area에 저장되는 정보들은 다음과 같다\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"패키지 명이 전부 포함된 클래스 경로(Fully Qualified Name), 해당 클래스의 부모 클래스\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"‘.class’파일이 Class인지, Interface인지 Enum인지 여부\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"접근 한정자(private, public …)와 메서드 정보 등\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"JVM이 클래스를 불러올 때 사용하는 3가지 로더는 다음과 같다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Bootstrap ClassLoader\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"최상위 ClassLoader이다. 이 로더가 JAR파일이나\", _jsx(_components.code, {\n                children: \" $JAVA_HOME/jre/lib\"\n              }), \" 경로의 코어 라이브러리에서 패키지를 불러온다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Extension ClassLoader\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"Bootstrap 클래스 로더의 하위 클래스이고, Application ClassLoader의 상위 클래스이다.\"\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \"$JAVA_HOME/jre/lib/ext\"\n              }), \" 경로에서 패키지 파일을 불러온다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Application ClassLoader\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"이 클래스로더는 classpath의 파일들을 불러온다. (기본 경로값은 현재 어플리케이션 디렉토리)\"\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"클래스를 못 찾으면 \", _jsx(_components.code, {\n                children: \"ClassNotFoundError\"\n              }), \"를 던진다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"2. 정보를 읽어온 후엔 클래스 타입의 오브젝트를 생성한다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"JVM이 클래스를 처음 로딩해오면 JVM은 \", _jsx(_components.code, {\n            children: \"java.lang\"\n          }), \" 패키지에 정의된 \", _jsx(_components.code, {\n            children: \"Class\"\n          }), \" 클래스에서 오브젝트를 생성한다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"이 클래스 오브젝트는 프로그래머가 클래스들의 정보(클래스명, 부모 클래스명, 메서드나 변수 정보 등)를 얻기 위해 사용할 수 있다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"클래스마다 하나의 오브젝트만 존재하도록 관리된다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"그리고 이 ‘Class’타입 오브젝트는 힙에 저장된다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Linking\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"1. Verification\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\".class파일을 로딩해올 때, bytecode verifier라는 프로그램이 .class파일을 검증한다.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"유효한 컴파일러로 컴파일 된 것인지.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"올바른 구조, 포맷인지.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"verification중 하나라도 실패하면 JVM은 verifier exception 에러를 런타임에 던진다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"2. Preparation\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"만약 클래스가 instance level이거나 static 변수를 가지고 있으면 기본값으로 초기화 시킨다. (설정해둔 초기값이 아님)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"ex. boolean → false, int → 0, 이런 식.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"3. Resolution\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"참조 변수들을 실제 메모리 주소값으로 변경한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Initialization\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"코드로 설정한 초기값들이 여기서 할당된다. 그리고 클래스의 정적 영역들이 실행된다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Memory Area (= Runtime Data Area)\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/jvm-runtime-data.png\",\n        alt: \"jvm runtime data\",\n        height: \"240px\",\n        sourceHref: \"https://www.freecodecamp.org\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Method Area\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"모든 클래스 정보. (method data, constructor details …)\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"JVM마다 하나가 존재하며, 다른 스레드들과 공유되는 공간이다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Heap\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"모든 오브젝트, static 변수(JAVA 8부터 적용)\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"JVM마다 하나가 존재하며, 다른 스레드들과 공유되는 공간이다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Stack\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"함수 호출마다 쌓임. 로컬 변수들이 저장된다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"각 스레드마다 존재하며, 스레드가 종료되면 해당 영역도 제거된다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"PC Register\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"각 스레드마다 존재하며, 현재 실행중인 명령어 위치를 저장한다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Native Method Stack\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"각 스레드마다 존재하며, native methods 정보를 저장한다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Execution Engine\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/jvm-execution-engine.png\",\n        alt: \"jvm execution engine\",\n        height: \"250px\",\n        sourceHref: \"https://www.freecodecamp.org\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \".class\"\n        }), \" 코드(bytecode)를 실행한다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Interpreter\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"bytecode를 읽으면서 machine code로 변환한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"JIT compiler\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"JVM은 처음엔 인터프리터를 쓰지만, 해석해야 할 bytecode가 반복적이면, JVM은 JIT를 대신 사용해서 전체 코드를 machine code로 컴파일한다. (매번 같은 코드에 대해 인터프리터를 사용하는 것 보다 한번에 컴파일해서 최적화 하는게 더 빠르기 때문)\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"JIT compiler는 다음과 같은 4가지로 이루어져 있다\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"Intermediate Code Generator - 중간 코드 생성\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"Code Optimizer - 코드 최적화\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"Target Code Generator - 머신 코드 생성\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"Profiler - 최적화를 위해 반복되는 코드를 찾음(hotspot)\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"GC(Garbage Collector)\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"C 같은 언어들은 프로그래머가 직접 메모리를 할당/해제 해야 하지만 Java는 JVM이 알아서 처리해준다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"GC는 백그라운드로 실행되면서 주기적으로, 더 이상의 참조가 없는 Heap 상의 오브젝트들을 해제한다.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"Mark → 메모리에서 더 이상 쓰지 않는 오브젝트들을 마킹.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"Sweep → 마킹된 오브젝트들을 해제.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"GC 방법엔 여러가지가 있다.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"Serial GC → 싱글스레드 환경으로 돌아감. GC가 동작하면 어플리케이션이 멎어버림.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"Parallel GC → 멀티 스레드를 이용. (하지만 여전히 어플리케이션이 멎을 때가 있음)\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"G1GC\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"JNI interface\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"JVM에서 실행하는 자바 코드가 네이티브 응용 프로그램이나 다른 언어로 작성된 라이브러리를 호출/호출되는 것을 가능하게 하는 프레임워크. .dll 또는 .so 포맷.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"참고\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: _jsx(_components.a, {\n              href: \"https://hasithas.medium.com/understanding-how-java-virtual-machine-jvm-works-a1b07c0c399a\",\n              children: \"https://hasithas.medium.com/understanding-how-java-virtual-machine-jvm-works-a1b07c0c399a\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: _jsx(_components.a, {\n              href: \"https://www.geeksforgeeks.org/jvm-works-jvm-architecture/\",\n              children: \"https://www.geeksforgeeks.org/jvm-works-jvm-architecture/\"\n            })\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}