{"pageProps":{"frontMatter":{"title":"[자바 스터디] 2주차 정리","description":null,"uploaded":"2023-01-18","updated":null,"tags":["study-halle","java"],"draft":false},"slug":"java-study-halle-2nd-week","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      hr: \"hr\",\n      table: \"table\",\n      thead: \"thead\",\n      tr: \"tr\",\n      th: \"th\",\n      tbody: \"tbody\",\n      td: \"td\",\n      code: \"code\",\n      h3: \"h3\",\n      pre: \"pre\",\n      strong: \"strong\",\n      a: \"a\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(Image, {\n        src: \"/study-halle.jpeg\",\n        alt: \"study halle image\",\n        height: \"400px\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"목표\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"학습할 것\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"프리미티브 타입 종류와 값의 범위 그리고 기본 값\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프리미티브 타입과 레퍼런스 타입\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"리터럴\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"변수 선언 및 초기화하는 방법\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"변수의 스코프와 라이프타임\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"타입 변환, 캐스팅 그리고 타입 프로모션\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"1차 및 2차 배열 선언하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"타입 추론, var\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n        children: \"Primitive Type\"\n      }), \"\\n\", _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Type\"\n            }), _jsx(_components.th, {\n              children: \"Contains\"\n            }), _jsx(_components.th, {\n              children: \"Default\"\n            }), _jsx(_components.th, {\n              children: \"Size\"\n            }), _jsx(_components.th, {\n              children: \"Range\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"boolean\"\n            }), _jsx(_components.td, {\n              children: \"true or false\"\n            }), _jsx(_components.td, {\n              children: \"false\"\n            }), _jsx(_components.td, {\n              children: \"1bit\"\n            }), _jsx(_components.td, {})]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"char\"\n            }), _jsx(_components.td, {\n              children: \"unicode\"\n            }), _jsx(_components.td, {\n              children: \"\\\\u0000\"\n            }), _jsx(_components.td, {\n              children: \"16bits\"\n            }), _jsx(_components.td, {\n              children: \"\\\\u0000 ~ \\\\uffff\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"byte\"\n            }), _jsx(_components.td, {\n              children: \"signed integer\"\n            }), _jsx(_components.td, {\n              children: \"0\"\n            }), _jsx(_components.td, {\n              children: \"8bits\"\n            }), _jsx(_components.td, {\n              children: \"-128 ~ 127\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"short\"\n            }), _jsx(_components.td, {\n              children: \"signed integer\"\n            }), _jsx(_components.td, {\n              children: \"0\"\n            }), _jsx(_components.td, {\n              children: \"16bits\"\n            }), _jsx(_components.td, {\n              children: \"–32768 ~ 32767\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"int\"\n            }), _jsx(_components.td, {\n              children: \"signed integer\"\n            }), _jsx(_components.td, {\n              children: \"0\"\n            }), _jsx(_components.td, {\n              children: \"32bits\"\n            }), _jsx(_components.td, {\n              children: \"–2147483648 ~ 2147483647\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"long\"\n            }), _jsx(_components.td, {\n              children: \"signed integer\"\n            }), _jsx(_components.td, {\n              children: \"0\"\n            }), _jsx(_components.td, {\n              children: \"64bits\"\n            }), _jsx(_components.td, {\n              children: \"9223372036854775808 ~ 9223372036854775807\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"float\"\n            }), _jsx(_components.td, {\n              children: \"IEEE 754 floating point\"\n            }), _jsx(_components.td, {\n              children: \"0.0\"\n            }), _jsx(_components.td, {\n              children: \"32bits\"\n            }), _jsx(_components.td, {\n              children: \"1.4E–45 ~ 3.4028235E+38\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"double\"\n            }), _jsx(_components.td, {\n              children: \"IEEE 754 floating point\"\n            }), _jsx(_components.td, {\n              children: \"0.0\"\n            }), _jsx(_components.td, {\n              children: \"64bits\"\n            }), _jsx(_components.td, {\n              children: \"4.9E–324 ~ 1.7976931348623157E+308\"\n            })]\n          })]\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"+) Java에는 \", _jsx(_components.code, {\n          children: \"unsigned\"\n        }), \" primitive type이 없다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Primitive vs Reference\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Primitve는 프로그래머가 정의할 수 없음.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Primitive는 값 자체를 표현하지만, Reference 타입은 메모리 참조 값임.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Primitive는 값을 항상 전체 복사해서 전달하지만, Reference는 해당 메모리 값만을 전달하며, 메모리는 힙에 저장되어 GC의 대상이 된다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Boxing, Unboxing\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Java에서는 Primitive type의 Wrapper클래스(\", _jsx(_components.code, {\n          children: \"Boolean\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Byte\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Short\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Character\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Integer\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Long\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Float\"\n        }), \", \", _jsx(_components.code, {\n          children: \"Double\"\n        }), \")를 제공하고, 주로 Collection에 값을 저장할 때 사용한다(Generic은 참조 값만 지원하기 때문). ex \", _jsx(_components.code, {\n          children: \"List<Integer>\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Boxing : Primitive → Reference\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Unboxing: Reference → Primitive\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Java에서 boxing,unboxing은 타입 캐스팅 필요없이 자동으로 일어난다. 불필요한 boxing, unboxing은 성능 오버헤드가 발생하므로 Collections로 쓰는게 아니라면 Primitive를 쓰자.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Literal\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"상수값을 나타내는 문자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"1    1.0    '1'    1L    \\\"one\\\"    true    false    null\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"integer literal → int로 취급.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"long → \", _jsx(_components.code, {\n                children: \"L\"\n              }), \" , octa → \", _jsx(_components.code, {\n                children: \"0\"\n              }), \" , hex → \", _jsx(_components.code, {\n                children: \"0x\"\n              }), \" , binary → \", _jsx(_components.code, {\n                children: \"0b\"\n              }), \"를 붙여야 함\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"floating point는 overflow나면 Infinity. underflow나면 0.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"double inf = 1.0/0.0;             // Infinity\\ndouble neginf = -1.0/0.0;         // Negative infinity\\ndouble negzero = -1.0/inf;        // Negative zero\\ndouble NaN = 0.0/0.0;             // Not a Number\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"변수 선언 및 초기화\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"int <변수 이름> = 0; // primitive type\\nPlayer <변수 이름> = new Player(); // reference type은 new와 생성자 함수로 초기화\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"변수의 스코프와 라이프타임\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"클래스 변수 - 클래스로더가 클래스를 로딩할 때 메모리에 할당 (static). 모든 클래스 인스턴스가 해당 변수를 공유.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"인스턴스 변수 - 인스턴스가 생성될 때 메모리에 할당되고 인스턴스가 해제될 때 같이 해제됨.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"지역 변수 - 메서드 내에서 선언. 메서드 내에서만 사용 가능\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"타입 변환, 캐스팅 그리고 타입 프로모션\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"타입 변환\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"변수의 타입을 다른 타입으로 변경하는 것\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"타입 캐스팅 (강제 변환)\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \"()\"\n              }), \" 연산자를 이용해 강제로 형변환한다.\"]\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"강제로 형변환하기 때문에 값 손실이 있을 수 있다. ex \", _jsx(_components.code, {\n                children: \"(int)3.14f -> 3\"\n              })]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"타입 프로모션 (자동 변환)\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"하위 타입이 상위 타입으로 변경되는 경우.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: _jsx(_components.code, {\n                children: \"byte → short → int → long → float → double\"\n              })\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"1차 및 2차 배열 선언하기\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"int[] arr1 = new int[2]; // 1차원 배열\\n\\nint[][] arr = new int[2][3]; // 2x3 배열\\nint[][] arr = new int[][] {{1,0}, {2}}; // 선언과 동시 초기화, 서로 다른 길이로 선언 가능.\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"타입 추론, \", _jsx(_components.code, {\n          children: \"var\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"var list = new ArrayList<String>();\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Java10부터 추가된, 변수 선언 시 초기화 값을 바탕으로 타입을 추론해주는 키워드(.NET에도 있다).\\n선언 시 타입을 여러번 쓰지 않아도 되므로 코드를 깔끔하게 유지할 수 있으며, 표현하기 곤란한 타입을 나타내는데도 좋다.\\n다만 아래와 같은 경우들은 \", _jsx(_components.code, {\n          children: \"var\"\n        }), \" 키워드를 이용한 타입 추론이 불가능하다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"var x; // 초기화 필요\\nvar x = null // null로는 초기화 불가\\nvar arr = {1,2,3} // 배열 초기화는 불가\\nvar f = () -> {} // lambda 불가\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"참고\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://learning.oreilly.com/library/view/java-in-a/9781492037248/\",\n            children: \"[Book] Java in a Nutshell 7th Edition\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://youtube.com/playlist?list=PLfI752FpVCS96fSsQe2E3HzYTgdmbz6LU\",\n            children: \"Study Halle\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}