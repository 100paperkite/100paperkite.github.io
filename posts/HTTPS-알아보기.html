<!DOCTYPE html><html lang="ko-KR"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:url" content="https://100paperkite.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko-KR"/><meta property="og:site_name" content="Baek Jiyeon"/><title>HTTPS 알아보기 | Baek Jiyeon</title><meta name="robots" content="index,follow"/><meta name="description" content="HTTPS 알아보기"/><meta property="og:title" content="HTTPS 알아보기 | Baek Jiyeon"/><meta property="og:description" content="HTTPS 알아보기"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2022-03-15","description":"HTTPS 알아보기","mainEntityOfPage":{"@type":"WebPage","@id":"https://100paperkite.github.io/posts/HTTPS-알아보기"},"headline":"HTTPS 알아보기","dateModified":"2022-03-15T14:23:27.979Z","author":{"@type":"Person","name":"Baek Jiyeon"}}</script><meta name="next-head-count" content="12"/><script id="gtag-init" strategy="afterInteractive">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-FFSLQ27YMJ', {
                page_path: window.location.pathname,
              });
            </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FFSLQ27YMJ"></script><link rel="preload" href="/_next/static/css/821c3b988c48b0a6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/821c3b988c48b0a6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b541ff9a7aaba70c.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-1b1db7be3343898e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4950b4b931360bc8.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-aee1a03cbb0f41ac.js" defer=""></script><script src="/_next/static/chunks/17007de1-711cf284c97b49d4.js" defer=""></script><script src="/_next/static/chunks/2596-e9cc441945f84dbb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-6a1e3d24afeaf810.js" defer=""></script><script src="/_next/static/9OaPJRZr8NJ8VsM8Sxx4w/_buildManifest.js" defer=""></script><script src="/_next/static/9OaPJRZr8NJ8VsM8Sxx4w/_ssgManifest.js" defer=""></script><script src="/_next/static/9OaPJRZr8NJ8VsM8Sxx4w/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><nav class="flex justify-between sticky top-0 z-50 space-x-4 py-2"><a class="text-neutral-800 hover:text-neutral-600 md:text-xl font-bold mx-4 md:mx-6 my-1 md:my-2 p-2 " href="/">Baek Jiyeon</a></nav><main class="max-w-[820px] px-4 w-full mx-auto flex-grow font-body"><div class="px-2 md:px-4 py-2 md:py-4"><div class="border-b border-1 mb-4 sm:mb-6 border-dashed border-neutral-300"><div class="flex items-center my-1 md:my-2 gap-x-2"><div class="text-xs rounded-2xl bg-neutral-300 text-neutral-600 font-semibold px-3.5 py-1">network</div><div class="text-xs rounded-2xl bg-neutral-300 text-neutral-600 font-semibold px-3.5 py-1">http</div><div class="text-xs rounded-2xl bg-neutral-300 text-neutral-600 font-semibold px-3.5 py-1">security</div></div><h1 class="text-4xl sm:text-[44px] font-extrabold mb-2 sm:mb-4 mt-6 sm:mt-10">HTTPS 알아보기</h1><div class="flex py-2 md:py-3 pl-1 text-neutral-500"><small class="">March 15, 2022<!-- -->에 작성</small></div></div><article class="max-w-none prose prose-neutral prose-sm sm:prose-base md:prose-md"><p>GeekNews를 보던 중 <a href="https://news.hada.io/topic?id=6144">로컬 개발환경에서 HTTPS 이용하기</a> 라는 글을 보았다. HTTPS와 HTTP의 차이는 암호화 여부.. 정도로만 알고 있었기 때문에, 글을 읽어보면서 궁금해져서 좀 더 알아보았다.</p>
<h2>HTTPS?</h2>
<p>HTTPS는 HTTP와는 달리 TLS(Transport Layer Security)라는 암호화 프로토콜을 이용해, 서버와 클라이언트가 서로 주고받는 데이터를 암호화 한다.</p>
<p>이 방식을 이용해서</p>
<ul>
<li>클라이언트와 서버는 데이터를 주고 받는 상대가 서로임을 확인할 수 있고</li>
<li>주고 받는 데이터는 모두 암호화되어서 제 3자가 알아볼 수 없게 된다.</li>
</ul>
<p>그리고 HTTPS는 위와 같은 암호화를 위해 <strong>공개키 암호화</strong>방식을 이용한다.</p>
<h2>🔐 공개 키 암호화 방식</h2>
<p><code>공개 키</code> 와 <code>개인 키</code> 라는 두 개의 키를 이용해 데이터를 암호화/복호화 하는 알고리즘이다.
공개키는 말 그대로, 외부에 공개되어도 되는 키 값이며, 개인 키는 외부에 공개하면 안되는 키 값이다. 그리고 공개키로 암호화 한 값은 개인 키로만 복호화 가능하다.</p>
<p>클라이언트가 서버에 데이터를 보내기 위해선 서버의 공개키를 이용해 데이터를 암호화한 후 데이터를 보낸다. 이 데이터는 서버의 개인 키로만 해독할 수 있으므로 중간에 누군가가 패킷을 가로채더라도, 서버의 비밀키가 없으므로 해독할 수 없게된다. 따라서 안전하게 클라이언트와 서버가 통신을 할 수 있게 된다.</p>
<h2>📝 인증 기관 (Certificate Authority)</h2>
<p>클라이언트가 서버에 HTTPS로 접속하게 되면, 서버는 공개키를 바로 보내는 것이 아니라 <strong>인증기관이 서명한 인증서</strong>를 보내주는데, 이 인증서에 <strong>공개키</strong>가 담겨있다.</p>
<p>여기서 <strong>인증기관</strong>은 서버가 정보를 탈취하고자 하는 제 3자가 아니라 신뢰할만한 서버인지 확인해주는 역할을 한다. 그렇기 때문에 HTTPS 연결을 허용하고자 하는 서버는 인증기관에서 인증서를 발급받아야 한다 (<code>Let&#x27;s encrypt</code> 처럼 인증기관을 거치지 않고 자체 발급하는 방법도 있다).</p>
<p>인증 기관은 하나만 존재하는 것이 아니라 여러 개 존재하며, 계층적인 구조로 되어있다. 최상위엔 모두가 신뢰하기로 협의한 root 인증기관이 있다. root 인증기관 하위에 중간 인증기관들이 있는데, 서버가 인증서 발급을 원하는 경우 이 중간 인증기관에서 인증서를 발급받는다. 상위 인증기관이 하위 인증기관을 검증해주는 식이라, 중간 인증기관에서 발급받아도 root가 인증한 인증서가 된다.</p>
<p>이러한 연결관계를 인증서 체인(Certificate Chain)이라 하며, 직접 인증서에서 확인해 볼 수도 있다. 브라우저 주소 창 왼쪽의 자물쇠 표시 🔒를 눌러서 인증서를 보면 아래와 같은 인증서 체인을 볼 수 있다.</p>
<figure class="text-center pt-1 sm:pt-2 md:pt-3"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27500%27%20height=%27300%27/%3e"/></span><img alt="certificate chain" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="flex rounded" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="certificate chain" src="/certificate-chain.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="flex rounded" loading="lazy"/></noscript></span><div><a class="text-xs underline text-neutral-500"></a></div></figure>
<p>인증기관은 자신의 개인 키로 인증서를 암호화(서명)하여 서버에게 발급해준다. 클라이언트는 인증 기관의 공개키로 서버의 인증서를 해독하여 서버가 신뢰할만한 서버인지 확인한다.</p>
<p>브라우저의 경우 주요 인증기관의 공개키를 이미 가지고 있기 때문에, 서버의 인증서를 검증할 때 마다 인증기관에서 공개키를 가져오는 것이 아니라 이미 가지고 있는 공개키로 인증서를 해독한다.</p>
<h2>정리</h2>
<ul>
<li>HTTPS는 공개키 암호화 방식으로 데이터를 암호화하고, 서로의 신원을 확인할 수 있게 한다.</li>
<li>HTTPS를 지원할 서버는 인증기관에서 인증서를 발급받아야 한다.</li>
<li>클라이언트는 서버에게서 인증서를 받으면, 인증서의 인증기관 공개키로 인증서를 해독한다.</li>
<li>클라이언트는 인증기관을 확인하여 인증기관이 신뢰할만한 곳인지 알 수 있다.</li>
<li>인증서를 해독한 후 인증서의 공개키로 데이터를 암호화하여 서버와 통신을 시작한다.</li>
</ul></article></div></main><footer class="font-title py-4 sm:py-8 flex flex-col items-center text-neutral-600"><div class="flex flex-row my-2"><div class="flex items-center py-1"><a class="m-2 " href="https://github.com/100paperkite"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.976 0A7.977 7.977 0 0 0 0 7.976c0 3.522 2.3 6.507 5.431 7.584.392.049.538-.196.538-.392v-1.37c-2.201.49-2.69-1.076-2.69-1.076-.343-.93-.881-1.175-.881-1.175-.734-.489.048-.489.048-.489.783.049 1.224.832 1.224.832.734 1.223 1.859.88 2.3.685.048-.538.293-.88.489-1.076-1.762-.196-3.621-.881-3.621-3.964 0-.88.293-1.566.832-2.153-.05-.147-.343-.978.098-2.055 0 0 .685-.196 2.201.832.636-.196 1.322-.245 2.007-.245s1.37.098 2.006.245c1.517-1.027 2.202-.832 2.202-.832.44 1.077.146 1.908.097 2.104a3.16 3.16 0 0 1 .832 2.153c0 3.083-1.86 3.719-3.62 3.915.293.244.538.733.538 1.467v2.202c0 .196.146.44.538.392A7.984 7.984 0 0 0 16 7.976C15.951 3.572 12.38 0 7.976 0z"></path></svg></a><a class="m-2" href="mailto:100.paperkite@gmail.com"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5l.5-.5h13l.5.5v9l-.5.5h-13l-.5-.5v-9zm1 1.035V12h12V4.536L8.31 8.9H7.7L2 4.535zM13.03 4H2.97L8 7.869 13.03 4z"></path></svg></a></div></div><span class="text-sm md:text-base text-neutral-500">Baek Jiyeon<!-- --> © <!-- -->2022</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"HTTPS 알아보기","uploaded":"2022-03-15","updated":"2022-03-15T14:23:27.979Z","tags":["network","http","security"],"draft":false},"slug":"HTTPS-알아보기","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\",\n      strong: \"strong\",\n      code: \"code\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"GeekNews를 보던 중 \", _jsx(_components.a, {\n          href: \"https://news.hada.io/topic?id=6144\",\n          children: \"로컬 개발환경에서 HTTPS 이용하기\"\n        }), \" 라는 글을 보았다. HTTPS와 HTTP의 차이는 암호화 여부.. 정도로만 알고 있었기 때문에, 글을 읽어보면서 궁금해져서 좀 더 알아보았다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"HTTPS?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"HTTPS는 HTTP와는 달리 TLS(Transport Layer Security)라는 암호화 프로토콜을 이용해, 서버와 클라이언트가 서로 주고받는 데이터를 암호화 한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 방식을 이용해서\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"클라이언트와 서버는 데이터를 주고 받는 상대가 서로임을 확인할 수 있고\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"주고 받는 데이터는 모두 암호화되어서 제 3자가 알아볼 수 없게 된다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그리고 HTTPS는 위와 같은 암호화를 위해 \", _jsx(_components.strong, {\n          children: \"공개키 암호화\"\n        }), \"방식을 이용한다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"🔐 공개 키 암호화 방식\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"공개 키\"\n        }), \" 와 \", _jsx(_components.code, {\n          children: \"개인 키\"\n        }), \" 라는 두 개의 키를 이용해 데이터를 암호화/복호화 하는 알고리즘이다.\\n공개키는 말 그대로, 외부에 공개되어도 되는 키 값이며, 개인 키는 외부에 공개하면 안되는 키 값이다. 그리고 공개키로 암호화 한 값은 개인 키로만 복호화 가능하다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"클라이언트가 서버에 데이터를 보내기 위해선 서버의 공개키를 이용해 데이터를 암호화한 후 데이터를 보낸다. 이 데이터는 서버의 개인 키로만 해독할 수 있으므로 중간에 누군가가 패킷을 가로채더라도, 서버의 비밀키가 없으므로 해독할 수 없게된다. 따라서 안전하게 클라이언트와 서버가 통신을 할 수 있게 된다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"📝 인증 기관 (Certificate Authority)\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"클라이언트가 서버에 HTTPS로 접속하게 되면, 서버는 공개키를 바로 보내는 것이 아니라 \", _jsx(_components.strong, {\n          children: \"인증기관이 서명한 인증서\"\n        }), \"를 보내주는데, 이 인증서에 \", _jsx(_components.strong, {\n          children: \"공개키\"\n        }), \"가 담겨있다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"여기서 \", _jsx(_components.strong, {\n          children: \"인증기관\"\n        }), \"은 서버가 정보를 탈취하고자 하는 제 3자가 아니라 신뢰할만한 서버인지 확인해주는 역할을 한다. 그렇기 때문에 HTTPS 연결을 허용하고자 하는 서버는 인증기관에서 인증서를 발급받아야 한다 (\", _jsx(_components.code, {\n          children: \"Let's encrypt\"\n        }), \" 처럼 인증기관을 거치지 않고 자체 발급하는 방법도 있다).\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"인증 기관은 하나만 존재하는 것이 아니라 여러 개 존재하며, 계층적인 구조로 되어있다. 최상위엔 모두가 신뢰하기로 협의한 root 인증기관이 있다. root 인증기관 하위에 중간 인증기관들이 있는데, 서버가 인증서 발급을 원하는 경우 이 중간 인증기관에서 인증서를 발급받는다. 상위 인증기관이 하위 인증기관을 검증해주는 식이라, 중간 인증기관에서 발급받아도 root가 인증한 인증서가 된다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이러한 연결관계를 인증서 체인(Certificate Chain)이라 하며, 직접 인증서에서 확인해 볼 수도 있다. 브라우저 주소 창 왼쪽의 자물쇠 표시 🔒를 눌러서 인증서를 보면 아래와 같은 인증서 체인을 볼 수 있다.\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/certificate-chain.png\",\n        alt: \"certificate chain\",\n        width: \"500px \",\n        height: \"300px\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"인증기관은 자신의 개인 키로 인증서를 암호화(서명)하여 서버에게 발급해준다. 클라이언트는 인증 기관의 공개키로 서버의 인증서를 해독하여 서버가 신뢰할만한 서버인지 확인한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"브라우저의 경우 주요 인증기관의 공개키를 이미 가지고 있기 때문에, 서버의 인증서를 검증할 때 마다 인증기관에서 공개키를 가져오는 것이 아니라 이미 가지고 있는 공개키로 인증서를 해독한다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"정리\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"HTTPS는 공개키 암호화 방식으로 데이터를 암호화하고, 서로의 신원을 확인할 수 있게 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"HTTPS를 지원할 서버는 인증기관에서 인증서를 발급받아야 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"클라이언트는 서버에게서 인증서를 받으면, 인증서의 인증기관 공개키로 인증서를 해독한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"클라이언트는 인증기관을 확인하여 인증기관이 신뢰할만한 곳인지 알 수 있다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"인증서를 해독한 후 인증서의 공개키로 데이터를 암호화하여 서버와 통신을 시작한다.\"\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"HTTPS-알아보기"},"buildId":"9OaPJRZr8NJ8VsM8Sxx4w","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>