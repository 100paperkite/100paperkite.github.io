<!DOCTYPE html><html lang="ko-KR"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:url" content="https://100paperkite.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko-KR"/><meta property="og:site_name" content="Baek Jiyeon"/><title>JavaScript 모듈 | Baek Jiyeon</title><meta name="robots" content="index,follow"/><meta name="description" content="JavaScript 모듈"/><meta property="og:title" content="JavaScript 모듈 | Baek Jiyeon"/><meta property="og:description" content="JavaScript 모듈"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2022-03-27","description":"JavaScript 모듈","mainEntityOfPage":{"@type":"WebPage","@id":"https://100paperkite.github.io/posts/JavaScript-모듈"},"headline":"JavaScript 모듈","dateModified":"2022-03-27T09:04:32.247Z","author":{"@type":"Person","name":"Baek Jiyeon"}}</script><meta name="next-head-count" content="12"/><script id="gtag-init" strategy="afterInteractive">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-FFSLQ27YMJ', {
                page_path: window.location.pathname,
              });
            </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FFSLQ27YMJ"></script><link rel="preload" href="/_next/static/css/fa2c6914801087f9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fa2c6914801087f9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b520f36895b439d6.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-1b1db7be3343898e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4950b4b931360bc8.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-aee1a03cbb0f41ac.js" defer=""></script><script src="/_next/static/chunks/17007de1-711cf284c97b49d4.js" defer=""></script><script src="/_next/static/chunks/2596-e9cc441945f84dbb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-067bc773ae7f0545.js" defer=""></script><script src="/_next/static/mremkHPJQCHND78XnXGwi/_buildManifest.js" defer=""></script><script src="/_next/static/mremkHPJQCHND78XnXGwi/_ssgManifest.js" defer=""></script><script src="/_next/static/mremkHPJQCHND78XnXGwi/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><nav class="flex justify-between sticky top-0 z-50 space-x-4 py-2"><a class="text-neutral-800 hover:text-neutral-600 md:text-xl font-bold mx-4 md:mx-6 my-1 md:my-2 p-2 " href="/">Baek Jiyeon</a></nav><main class="max-w-[820px] px-4 w-full mx-auto flex-grow font-body"><div class="px-2 md:px-4 py-2 md:py-4"><div class="border-b border-1 mb-4 sm:mb-6 border-dashed border-neutral-300"><div class="flex items-center my-1 md:my-2 gap-x-2"><div class="text-xs rounded-2xl bg-neutral-300 text-neutral-600 font-semibold px-3.5 py-1">javascript</div></div><h1 class="text-4xl sm:text-[44px] font-extrabold mb-2 sm:mb-4 mt-6 sm:mt-10">JavaScript 모듈</h1><div class="flex py-2 md:py-3 pl-1 text-neutral-500"><small class="">March 27, 2022<!-- -->에 작성</small></div></div><article class="max-w-none prose prose-neutral prose-sm sm:prose-base md:prose-md"><blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript modules | MDN Docs</a>, <a href="https://ko.javascript.info/modules-intro">Module | ko.javascript.info</a> 포스팅을 참고하여 재정리해 본 글입니다.</p>
</blockquote>
<h1>배경</h1>
<p>옛날의 자바스크립트는 웹페이지에 간단한 상호작용을 추가하는 정도에 그쳤기 때문에 일반적으로 큰 스크립트가 필요하진 않았다.</p>
<p>하지만 상황이 많이 달라졌기에 큰 스크립트를 별도의 모듈로 분할하기 위한 매커니즘이 필요해졌지만 브라우저들의 지원은 더딘편이었는데<small>(<em>Node.js</em>나 여러 JavaScript 라이브러리/프레임워크들에선 이미 모듈 사용이 가능했다)</small>, 최근의 모던 브라우저들은 거의 다 네이티브로 모듈 시스템을 지원하고 있다.</p>
<p>브라우저가 네이티브로 모듈 시스템을 지원하기 때문에, 라이브러리에서 해결하지 못하는 <strong>모듈 로딩 속도의 최적화</strong>같은 점들에 있어서 훨씬 효율적이다.</p>
<h1>구문</h1>
<p><code>import</code>와 <code>export</code> 구문으로 우리는 모듈 시스템을 사용할 수 있다. 모듈은 단지 파일 하나에 불과하며, 스크립트 하나가 모듈 하나이다.</p>
<ul>
<li><code>export</code>로 외부 모듈이 해당 모듈의 변수나 함수에 접근할 수 있도록 할 수 있다. (모듈 내보내기)</li>
<li><code>import</code>로 외부 모듈의 기능을 가져올 수 있다. (모듈 가져오기)</li>
</ul>
<h1>일반 스크립트와 모듈의 차이점</h1>
<h2>1. 모듈은 항상 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode"><code>strict mode</code></a> 로 실행된다.</h2>
<p>따라서 브라우저에서 모듈 최상위 레벨의 <code>this</code>도 <code>window</code>가 아닌 <code>undefined</code>이다.</p>
<h2>2. 모듈 레벨 스코프</h2>
<p>모듈은 각자의 스코프를 가지므로, <code>export</code>, <code>import</code>로 다른 모듈에 접근해야 한다.</p>
<h2>3. 단 한 번의 평가</h2>
<p>동일한 모듈이 여러 곳에서 사용되더라도, 모듈은 최초 호출 시 단 한번만 실행된다.</p>
<h2>4. 브라우저 특정 기능</h2>
<p>브라우저환경에서는 모듈을 스크립트에 <code>type=&quot;module&quot;</code>을 붙여 사용한다.</p>
<h3>지연 실행</h3>
<p>모듈 스크립트는 항상 <code>defer</code> 속성을 붙인 것 처럼 실행된다.
<code>defer</code> 속성은 해당 스크립트를 백그라운드에서 다운로드하므로, script를 다운로드 하는 도중에도 HTML 파싱이 멈추지 않는다. 그리고 다운로드된 스크립트는 페이지 구성이 끝난 후에 실행된다.</p>
<p>따라서 모듈 스크립트는 항상 완전한 HTML 페이지를 볼 수 있고, 문서 내 요소에도 접근할 수 있다.</p>
<h3>인라인 스크립트의 비동기 처리</h3>
<p>일반 스크립트에서 <code>async</code> 속성은 외부 스크립트를 불러올 때만 유효하다. (ex. `<script async="" src="..."></script>) 이 속성이 붙은 스크립트는 로딩이 끝나면 다른 스크립트나 HTML 문서가 처리되길 기다리지 않고 바로 실행된다.</p>
<p>그런데 모듈 스크립트에선 <code>async</code>속성을 인라인 스크립트에도 적용할 수 있다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-xml">&lt;!-- 필요한 모듈(analytics.js)의 로드가 끝나면 --&gt;
&lt;!-- 문서나 다른 &lt;script&gt;가 로드되길 기다리지 않고 바로 실행된다.--&gt;
&lt;script async type=&quot;module&quot;&gt;
  import { counter } from &#x27;./analytics.js&#x27;;
  counter.count();
&lt;/script&gt;</code></pre>
<h3>외부 스크립트</h3>
<p><code>type=&quot;module&quot;</code>가 붙은 외부 모듈 스크립트의 경우 다음과 같은 특징들이 있다.</p>
<ol>
<li><code>src</code> 속성 값이 동일한 외부 스크립트는 한 번만 실행된다.</li>
</ol>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-xml">&lt;script type=&quot;module&quot; src=&quot;once.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;once.js&quot;&gt;&lt;/script&gt;</code></pre>
<ol start="2">
<li>다른 origin에서 모듈을 불러오려면 서버가 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/CORS">CORS</a> 를 지원해야 한다.</li>
</ol>
<h3>경로가 없는 모듈은 안됨</h3>
<p>브라우저 환경에서는 <code>import</code>에 무조건 경로가 있어야 한다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">import { counter } from &#x27;Counter&#x27;; // Error
// ./Counter.js 처럼 경로와 확장자 명을 지정해야 한다.</code></pre>
<h3>nomodule</h3>
<p><code>type=&quot;module&quot;</code>을 해석하지 못하는 브라우저는 해당 타입의 스크립트를 무시하고 넘어가는데, <code>nomodule</code>속성을 사용하면 이를 대비할 수 있다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-xml">&lt;script type=&quot;module&quot;&gt;
  // 모던 브라우저에서는 이 스크립트가 실행된다.
&lt;/script&gt;

&lt;script nomodule&gt;
  // type=&quot;module&quot;을 해석할 수 있는 모던 브라우저에서는 이 스크립트를 무시하고 넘어간다.
  // type=&quot;module&quot;을 해석할 수 없는 브라우저에서 이 스크립트가 실행된다.
&lt;/script&gt;</code></pre>
<h1><code>.mjs</code>와 <code>.js</code></h1>
<p>간혹 코드를 보다보면 <code>.js</code> 확장자 대신 <code>.mjs</code> 확장자를 볼 수가 있다.</p>
<p><code>.mjs</code>확장자는 해당 자바스크립트 파일이 모듈인 지를 명확히 해주는 용도로 쓰인다.</p>
<p><em>Node.js</em> 런타임이나 <em>Babel</em> 같은 빌드 툴들이 해당 파일을 모듈로 취급할 수 있도록 해주기도 하고, 눈으로 봤을 때도 확장자만으로 해당 파일이 모듈인지 쉽게 알 수 있다.</p>
<div class="bg-rose-50 p-2 md:p-3 rounded-lg flex space-x-3"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7 text-rose-800" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8 4a.905.905 0 0 0-.9.995l.35 3.507a.552.552 0 0 0 1.1 0l.35-3.507A.905.905 0 0 0 8 4zm.002 6a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"></path></svg><div class="">가끔 <code>.cjs</code> 확장자도 보이는데, 이는 CommonJS로 작성된 스크립트를 뜻한다.</div></div>
<h3><code>.mjs</code> 확장자를 써야할까?</h3>
<p>브라우저에서 자바스크립트 파일을 모듈로 불러오도록 하려면 서버가 해당 파일을 보낼 때 <code>Content-Type</code> 헤더를 <code>text/javascript</code>같은 자바스크립트 MIME 타입으로 보내야 한다.</p>
<p>그렇지 않으면 <em>&quot;The server responded with a non-JavaScript MIME type&quot;</em> 에러가 나면서 브라우저가 해당 js 파일을 실행할 수 없다고 나온다.</p>
<p>대부분의 서버에선 <code>.js</code> 파일들은 정확한 MIME 타입으로 보내지만, <code>.mjs</code>의 경우엔 아닐 가능성이 높다.<small>(<em>GitHub Page</em> 나 <em>Node.js</em> 의 <em>http-server</em>같은 경우엔 <code>.mjs</code>를 다룰 수 있도록 되어있다.)</small></p>
<p>그러므로 내가 사용하는 툴이 <code>.mjs</code>를 지원하지 않아서 생길 수 있는 문제와 <code>.mjs</code>를 써서 얻을 수 있는 명확성의 트레이드 오프를 비교해보고 사용하는 것이 좋다.</p>
<p>그런데 <code>&lt;script type=&quot;module&quot;&gt;</code> 속성으로 해당 스크립트가 모듈임을 나타낼 수도 있기 때문에 <code>.js</code>를 그냥 사용하는 것이 나은 선택일 수도 있다.</p>
<h1>모듈 내보내고 가져오기</h1>
<h2><code>default export</code> vs <code>named export</code></h2>
<h3>named export</h3>
<p>한 모듈에서 여러 객체를 export할 수 있다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">export const name = &#x27;Jiyeon&#x27;;

// or
const name = &#x27;Jiyeon&#x27;;
export { name };</code></pre>
<h3>default export</h3>
<p>default export로 한 파일당 하나만 내보낼 수 있다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">const name = &#x27;Jiyeon&#x27;;

export { name as default };
export default name; // shortcut

// 익명 함수로 바로 export도 가능하다.
export default function(ctx) {

}

// 클래스도 가능
export default class {
  constructor(){ ... }
}</code></pre>
<h2><code>import</code></h2>
<p> import 방식은 다음과 같다. named는 named끼리, default는 default끼리 export, import가 가능하다.</p>
<h3>named import</h3>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">import { printName } from &#x27;./modules/name.js&#x27;;

// 한번에 가져오기
import * from &#x27;./modules/name.js&#x27;
printName(&#x27;Jiyeon&#x27;);

// 모듈에 이름붙여서 가져오기
import * as Name from &#x27;./modules/name.js&#x27;
Name.printName(&#x27;Jiyeon&#x27;);</code></pre>
<h3>default import</h3>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">import Name from &#x27;./modules/name.js&#x27;; // 어떤 이름으로도 import 할 수 있다
import { default as Name } from &#x27;./modules/name.js&#x27;; // 이렇게도 쓸 수 있다.</code></pre>
<div class="bg-rose-50 p-2 md:p-3 rounded-lg flex space-x-3"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7 text-rose-800" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8 4a.905.905 0 0 0-.9.995l.35 3.507a.552.552 0 0 0 1.1 0l.35-3.507A.905.905 0 0 0 8 4zm.002 6a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"></path></svg><div class="">몇몇 모듈 시스템에선 import할 때 <code>.js</code> 확장자를 빼도 되지만, 네이티브 모듈 시스템에선 동작하지
않으므로 확장자를 붙여야 한다.</div></div>
<h1>모듈 다시 내보내기</h1>
<p><code>export ... from ...</code> 문법을 사용하면 import한 개체를 다시 내보낼 수 있다. 주로 외부에 노출시키고 싶은 모듈을 관리하기 위해서 사용한다.</p>
<p>예를 들어 아래와 같은 폴더 구조가 있다고 가정해보자.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-text">modules/
  shapes.js
  shapes/
    circle.js
    square.js</code></pre>
<h2>named export</h2>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">// 외부 모듈에서 이렇게 각각 불러올 수도 있지만
import { Circle } from &#x27;./modules/shapes/circle.js&#x27;;
import { Square } from &#x27;./modules/shapes/square.js&#x27;;

//
// shape.js 에 이렇게 모듈을 다시 외부로 내보내면
export { Circle } from &#x27;./shapes/circle.js&#x27;;
export { Square } from &#x27;./shapes/square.js&#x27;;

// 외부 모듈에서 이렇게 불러올 수 있다.
import { Circle, Square } from &#x27;./modules/shapes.js&#x27;;</code></pre>
<h2>default export</h2>
<p>default의 경우엔 주의해야 할 점이 있다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">// circle.js
// default로 모듈을 내보내는 경우엔 처리가 달라진다.
export default class Circle {
  // ...
}

// shapes.js
export Circle from &#x27;./shapes/circle.js&#x27;; // Error!
export { default as Circle } from &#x27;./shapes/circle.js&#x27;; // 이렇게 내보내야 한다.</code></pre>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">// shapes.js
export * from &#x27;./circle.js&#x27;; // 이렇게 전체를 export하면 named export만 내보내진다.
export { default } from &#x27;./circle.js&#x27;; // 따라서 밑에 default export를 다시 내보내야 한다.</code></pre>
<h1>동적으로 모듈 로딩하기</h1>
<p>모든 모듈을 최상위 모듈에서 불러오지 않고, 모듈이 필요할 때 동적으로 불러올 수도 있다.</p>
<h3><code>import()</code> 표현식</h3>
<p><code>import(module)</code> 표현식은 해당 모듈을 읽고 이 모듈이 내보내는 것들을 모두 포함하는 객체<small>(<code>import * as Module from &#x27;module&#x27;</code>구문에서 Module이 이 객체이다.)</small>를 담은 <code>fulfilled</code>된 <code>Promise</code>를 반환한다.</p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">import(&#x27;./modules/shapes/circle.js&#x27;).then((Circle) =&gt; {
  Circle.drawCircle();
});

// 또는 async 함수 내부에서 await으로 불러올 수도 있다.
let Circle = await import(&#x27;./modules/shapes/circle.js&#x27;);
Circle.drawCircle();

// or
let { drawCircle } = await import(&#x27;./modules/shapes/circle.js&#x27;);
drawCircle();</code></pre>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">// default export의 경우엔 모듈 객체의 default 프로퍼티를 사용해야 한다.
let Circle = await import(&#x27;./modules/shapes/circle.js&#x27;);
let defaultExported = Circle.default;

// 위 코드는 아래와 같다.
let { default: defaultExported } = await import(&#x27;./modules/shapes/circle.js&#x27;);</code></pre></article><div><hr class="border-t border-neutral-300 my-8 sm:my-16"/><section></section></div></div></main><footer class="font-title py-4 sm:py-8 flex flex-col items-center text-neutral-600"><div class="flex flex-row my-2"><div class="flex items-center py-1"><a class="m-2 " href="https://github.com/100paperkite"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.976 0A7.977 7.977 0 0 0 0 7.976c0 3.522 2.3 6.507 5.431 7.584.392.049.538-.196.538-.392v-1.37c-2.201.49-2.69-1.076-2.69-1.076-.343-.93-.881-1.175-.881-1.175-.734-.489.048-.489.048-.489.783.049 1.224.832 1.224.832.734 1.223 1.859.88 2.3.685.048-.538.293-.88.489-1.076-1.762-.196-3.621-.881-3.621-3.964 0-.88.293-1.566.832-2.153-.05-.147-.343-.978.098-2.055 0 0 .685-.196 2.201.832.636-.196 1.322-.245 2.007-.245s1.37.098 2.006.245c1.517-1.027 2.202-.832 2.202-.832.44 1.077.146 1.908.097 2.104a3.16 3.16 0 0 1 .832 2.153c0 3.083-1.86 3.719-3.62 3.915.293.244.538.733.538 1.467v2.202c0 .196.146.44.538.392A7.984 7.984 0 0 0 16 7.976C15.951 3.572 12.38 0 7.976 0z"></path></svg></a><a class="m-2" href="mailto:100.paperkite@gmail.com"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5l.5-.5h13l.5.5v9l-.5.5h-13l-.5-.5v-9zm1 1.035V12h12V4.536L8.31 8.9H7.7L2 4.535zM13.03 4H2.97L8 7.869 13.03 4z"></path></svg></a></div></div><span class="text-sm md:text-base text-neutral-500">Baek Jiyeon<!-- --> © <!-- -->2022</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"JavaScript 모듈","description":null,"uploaded":"2022-03-27","updated":"2022-03-27T09:04:32.247Z","tags":["javascript"],"draft":false},"slug":"JavaScript-모듈","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      blockquote: \"blockquote\",\n      p: \"p\",\n      a: \"a\",\n      h1: \"h1\",\n      em: \"em\",\n      strong: \"strong\",\n      code: \"code\",\n      ul: \"ul\",\n      li: \"li\",\n      h2: \"h2\",\n      h3: \"h3\",\n      pre: \"pre\",\n      ol: \"ol\"\n    }, _provideComponents(), props.components), {Callout} = _components;\n    if (!Callout) _missingMdxReference(\"Callout\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\",\n            children: \"JavaScript modules | MDN Docs\"\n          }), \", \", _jsx(_components.a, {\n            href: \"https://ko.javascript.info/modules-intro\",\n            children: \"Module | ko.javascript.info\"\n          }), \" 포스팅을 참고하여 재정리해 본 글입니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"배경\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"옛날의 자바스크립트는 웹페이지에 간단한 상호작용을 추가하는 정도에 그쳤기 때문에 일반적으로 큰 스크립트가 필요하진 않았다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"하지만 상황이 많이 달라졌기에 큰 스크립트를 별도의 모듈로 분할하기 위한 매커니즘이 필요해졌지만 브라우저들의 지원은 더딘편이었는데\", _jsxs(\"small\", {\n          children: [\"(\", _jsx(_components.em, {\n            children: \"Node.js\"\n          }), \"나 여러 JavaScript 라이브러리/프레임워크들에선 이미 모듈 사용이 가능했다)\"]\n        }), \", 최근의 모던 브라우저들은 거의 다 네이티브로 모듈 시스템을 지원하고 있다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"브라우저가 네이티브로 모듈 시스템을 지원하기 때문에, 라이브러리에서 해결하지 못하는 \", _jsx(_components.strong, {\n          children: \"모듈 로딩 속도의 최적화\"\n        }), \"같은 점들에 있어서 훨씬 효율적이다.\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"구문\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"import\"\n        }), \"와 \", _jsx(_components.code, {\n          children: \"export\"\n        }), \" 구문으로 우리는 모듈 시스템을 사용할 수 있다. 모듈은 단지 파일 하나에 불과하며, 스크립트 하나가 모듈 하나이다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"export\"\n          }), \"로 외부 모듈이 해당 모듈의 변수나 함수에 접근할 수 있도록 할 수 있다. (모듈 내보내기)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"import\"\n          }), \"로 외부 모듈의 기능을 가져올 수 있다. (모듈 가져오기)\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"일반 스크립트와 모듈의 차이점\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"1. 모듈은 항상 \", _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode\",\n          children: _jsx(_components.code, {\n            children: \"strict mode\"\n          })\n        }), \" 로 실행된다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"따라서 브라우저에서 모듈 최상위 레벨의 \", _jsx(_components.code, {\n          children: \"this\"\n        }), \"도 \", _jsx(_components.code, {\n          children: \"window\"\n        }), \"가 아닌 \", _jsx(_components.code, {\n          children: \"undefined\"\n        }), \"이다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"2. 모듈 레벨 스코프\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"모듈은 각자의 스코프를 가지므로, \", _jsx(_components.code, {\n          children: \"export\"\n        }), \", \", _jsx(_components.code, {\n          children: \"import\"\n        }), \"로 다른 모듈에 접근해야 한다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"3. 단 한 번의 평가\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"동일한 모듈이 여러 곳에서 사용되더라도, 모듈은 최초 호출 시 단 한번만 실행된다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4. 브라우저 특정 기능\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"브라우저환경에서는 모듈을 스크립트에 \", _jsx(_components.code, {\n          children: \"type=\\\"module\\\"\"\n        }), \"을 붙여 사용한다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"지연 실행\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"모듈 스크립트는 항상 \", _jsx(_components.code, {\n          children: \"defer\"\n        }), \" 속성을 붙인 것 처럼 실행된다.\\n\", _jsx(_components.code, {\n          children: \"defer\"\n        }), \" 속성은 해당 스크립트를 백그라운드에서 다운로드하므로, script를 다운로드 하는 도중에도 HTML 파싱이 멈추지 않는다. 그리고 다운로드된 스크립트는 페이지 구성이 끝난 후에 실행된다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"따라서 모듈 스크립트는 항상 완전한 HTML 페이지를 볼 수 있고, 문서 내 요소에도 접근할 수 있다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"인라인 스크립트의 비동기 처리\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"일반 스크립트에서 \", _jsx(_components.code, {\n          children: \"async\"\n        }), \" 속성은 외부 스크립트를 불러올 때만 유효하다. (ex. `\", _jsx(\"script\", {\n          async: true,\n          src: \"...\"\n        }), \") 이 속성이 붙은 스크립트는 로딩이 끝나면 다른 스크립트나 HTML 문서가 처리되길 기다리지 않고 바로 실행된다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그런데 모듈 스크립트에선 \", _jsx(_components.code, {\n          children: \"async\"\n        }), \"속성을 인라인 스크립트에도 적용할 수 있다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-xml\",\n          children: \"\u003c!-- 필요한 모듈(analytics.js)의 로드가 끝나면 --\u003e\\n\u003c!-- 문서나 다른 \u003cscript\u003e가 로드되길 기다리지 않고 바로 실행된다.--\u003e\\n\u003cscript async type=\\\"module\\\"\u003e\\n  import { counter } from './analytics.js';\\n  counter.count();\\n\u003c/script\u003e\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"외부 스크립트\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"type=\\\"module\\\"\"\n        }), \"가 붙은 외부 모듈 스크립트의 경우 다음과 같은 특징들이 있다.\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"src\"\n          }), \" 속성 값이 동일한 외부 스크립트는 한 번만 실행된다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-xml\",\n          children: \"\u003cscript type=\\\"module\\\" src=\\\"once.js\\\"\u003e\u003c/script\u003e\\n\u003cscript type=\\\"module\\\" src=\\\"once.js\\\"\u003e\u003c/script\u003e\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        start: \"2\",\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"다른 origin에서 모듈을 불러오려면 서버가 \", _jsx(_components.a, {\n            href: \"https://developer.mozilla.org/ko/docs/Web/HTTP/CORS\",\n            children: \"CORS\"\n          }), \" 를 지원해야 한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"경로가 없는 모듈은 안됨\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"브라우저 환경에서는 \", _jsx(_components.code, {\n          children: \"import\"\n        }), \"에 무조건 경로가 있어야 한다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"import { counter } from 'Counter'; // Error\\n// ./Counter.js 처럼 경로와 확장자 명을 지정해야 한다.\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"nomodule\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"type=\\\"module\\\"\"\n        }), \"을 해석하지 못하는 브라우저는 해당 타입의 스크립트를 무시하고 넘어가는데, \", _jsx(_components.code, {\n          children: \"nomodule\"\n        }), \"속성을 사용하면 이를 대비할 수 있다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-xml\",\n          children: \"\u003cscript type=\\\"module\\\"\u003e\\n  // 모던 브라우저에서는 이 스크립트가 실행된다.\\n\u003c/script\u003e\\n\\n\u003cscript nomodule\u003e\\n  // type=\\\"module\\\"을 해석할 수 있는 모던 브라우저에서는 이 스크립트를 무시하고 넘어간다.\\n  // type=\\\"module\\\"을 해석할 수 없는 브라우저에서 이 스크립트가 실행된다.\\n\u003c/script\u003e\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h1, {\n        children: [_jsx(_components.code, {\n          children: \".mjs\"\n        }), \"와 \", _jsx(_components.code, {\n          children: \".js\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"간혹 코드를 보다보면 \", _jsx(_components.code, {\n          children: \".js\"\n        }), \" 확장자 대신 \", _jsx(_components.code, {\n          children: \".mjs\"\n        }), \" 확장자를 볼 수가 있다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \".mjs\"\n        }), \"확장자는 해당 자바스크립트 파일이 모듈인 지를 명확히 해주는 용도로 쓰인다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"Node.js\"\n        }), \" 런타임이나 \", _jsx(_components.em, {\n          children: \"Babel\"\n        }), \" 같은 빌드 툴들이 해당 파일을 모듈로 취급할 수 있도록 해주기도 하고, 눈으로 봤을 때도 확장자만으로 해당 파일이 모듈인지 쉽게 알 수 있다.\"]\n      }), \"\\n\", _jsx(Callout, {\n        children: _jsxs(_components.p, {\n          children: [\"가끔 \", _jsx(_components.code, {\n            children: \".cjs\"\n          }), \" 확장자도 보이는데, 이는 CommonJS로 작성된 스크립트를 뜻한다.\"]\n        })\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [_jsx(_components.code, {\n          children: \".mjs\"\n        }), \" 확장자를 써야할까?\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"브라우저에서 자바스크립트 파일을 모듈로 불러오도록 하려면 서버가 해당 파일을 보낼 때 \", _jsx(_components.code, {\n          children: \"Content-Type\"\n        }), \" 헤더를 \", _jsx(_components.code, {\n          children: \"text/javascript\"\n        }), \"같은 자바스크립트 MIME 타입으로 보내야 한다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그렇지 않으면 \", _jsx(_components.em, {\n          children: \"\\\"The server responded with a non-JavaScript MIME type\\\"\"\n        }), \" 에러가 나면서 브라우저가 해당 js 파일을 실행할 수 없다고 나온다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"대부분의 서버에선 \", _jsx(_components.code, {\n          children: \".js\"\n        }), \" 파일들은 정확한 MIME 타입으로 보내지만, \", _jsx(_components.code, {\n          children: \".mjs\"\n        }), \"의 경우엔 아닐 가능성이 높다.\", _jsxs(\"small\", {\n          children: [\"(\", _jsx(_components.em, {\n            children: \"GitHub Page\"\n          }), \" 나 \", _jsx(_components.em, {\n            children: \"Node.js\"\n          }), \" 의 \", _jsx(_components.em, {\n            children: \"http-server\"\n          }), \"같은 경우엔 \", _jsx(_components.code, {\n            children: \".mjs\"\n          }), \"를 다룰 수 있도록 되어있다.)\"]\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그러므로 내가 사용하는 툴이 \", _jsx(_components.code, {\n          children: \".mjs\"\n        }), \"를 지원하지 않아서 생길 수 있는 문제와 \", _jsx(_components.code, {\n          children: \".mjs\"\n        }), \"를 써서 얻을 수 있는 명확성의 트레이드 오프를 비교해보고 사용하는 것이 좋다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그런데 \", _jsx(_components.code, {\n          children: \"\u003cscript type=\\\"module\\\"\u003e\"\n        }), \" 속성으로 해당 스크립트가 모듈임을 나타낼 수도 있기 때문에 \", _jsx(_components.code, {\n          children: \".js\"\n        }), \"를 그냥 사용하는 것이 나은 선택일 수도 있다.\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"모듈 내보내고 가져오기\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [_jsx(_components.code, {\n          children: \"default export\"\n        }), \" vs \", _jsx(_components.code, {\n          children: \"named export\"\n        })]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"named export\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"한 모듈에서 여러 객체를 export할 수 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"export const name = 'Jiyeon';\\n\\n// or\\nconst name = 'Jiyeon';\\nexport { name };\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"default export\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"default export로 한 파일당 하나만 내보낼 수 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"const name = 'Jiyeon';\\n\\nexport { name as default };\\nexport default name; // shortcut\\n\\n// 익명 함수로 바로 export도 가능하다.\\nexport default function(ctx) {\\n\\n}\\n\\n// 클래스도 가능\\nexport default class {\\n  constructor(){ ... }\\n}\\n\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: _jsx(_components.code, {\n          children: \"import\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_Fragment, {}), \" import 방식은 다음과 같다. named는 named끼리, default는 default끼리 export, import가 가능하다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"named import\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"import { printName } from './modules/name.js';\\n\\n// 한번에 가져오기\\nimport * from './modules/name.js'\\nprintName('Jiyeon');\\n\\n// 모듈에 이름붙여서 가져오기\\nimport * as Name from './modules/name.js'\\nName.printName('Jiyeon');\\n\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"default import\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"import Name from './modules/name.js'; // 어떤 이름으로도 import 할 수 있다\\nimport { default as Name } from './modules/name.js'; // 이렇게도 쓸 수 있다.\\n\"\n        })\n      }), \"\\n\", _jsx(Callout, {\n        children: _jsxs(_components.p, {\n          children: [\"몇몇 모듈 시스템에선 import할 때 \", _jsx(_components.code, {\n            children: \".js\"\n          }), \" 확장자를 빼도 되지만, 네이티브 모듈 시스템에선 동작하지\\n않으므로 확장자를 붙여야 한다.\"]\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"모듈 다시 내보내기\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"export ... from ...\"\n        }), \" 문법을 사용하면 import한 개체를 다시 내보낼 수 있다. 주로 외부에 노출시키고 싶은 모듈을 관리하기 위해서 사용한다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"예를 들어 아래와 같은 폴더 구조가 있다고 가정해보자.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"modules/\\n  shapes.js\\n  shapes/\\n    circle.js\\n    square.js\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"named export\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"// 외부 모듈에서 이렇게 각각 불러올 수도 있지만\\nimport { Circle } from './modules/shapes/circle.js';\\nimport { Square } from './modules/shapes/square.js';\\n\\n//\\n// shape.js 에 이렇게 모듈을 다시 외부로 내보내면\\nexport { Circle } from './shapes/circle.js';\\nexport { Square } from './shapes/square.js';\\n\\n// 외부 모듈에서 이렇게 불러올 수 있다.\\nimport { Circle, Square } from './modules/shapes.js';\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"default export\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"default의 경우엔 주의해야 할 점이 있다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"// circle.js\\n// default로 모듈을 내보내는 경우엔 처리가 달라진다.\\nexport default class Circle {\\n  // ...\\n}\\n\\n// shapes.js\\nexport Circle from './shapes/circle.js'; // Error!\\nexport { default as Circle } from './shapes/circle.js'; // 이렇게 내보내야 한다.\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"// shapes.js\\nexport * from './circle.js'; // 이렇게 전체를 export하면 named export만 내보내진다.\\nexport { default } from './circle.js'; // 따라서 밑에 default export를 다시 내보내야 한다.\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"동적으로 모듈 로딩하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"모든 모듈을 최상위 모듈에서 불러오지 않고, 모듈이 필요할 때 동적으로 불러올 수도 있다.\"\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [_jsx(_components.code, {\n          children: \"import()\"\n        }), \" 표현식\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"import(module)\"\n        }), \" 표현식은 해당 모듈을 읽고 이 모듈이 내보내는 것들을 모두 포함하는 객체\", _jsxs(\"small\", {\n          children: [\"(\", _jsx(_components.code, {\n            children: \"import * as Module from 'module'\"\n          }), \"구문에서 Module이 이 객체이다.)\"]\n        }), \"를 담은 \", _jsx(_components.code, {\n          children: \"fulfilled\"\n        }), \"된 \", _jsx(_components.code, {\n          children: \"Promise\"\n        }), \"를 반환한다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"import('./modules/shapes/circle.js').then((Circle) =\u003e {\\n  Circle.drawCircle();\\n});\\n\\n// 또는 async 함수 내부에서 await으로 불러올 수도 있다.\\nlet Circle = await import('./modules/shapes/circle.js');\\nCircle.drawCircle();\\n\\n// or\\nlet { drawCircle } = await import('./modules/shapes/circle.js');\\ndrawCircle();\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"// default export의 경우엔 모듈 객체의 default 프로퍼티를 사용해야 한다.\\nlet Circle = await import('./modules/shapes/circle.js');\\nlet defaultExported = Circle.default;\\n\\n// 위 코드는 아래와 같다.\\nlet { default: defaultExported } = await import('./modules/shapes/circle.js');\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"JavaScript-모듈"},"buildId":"mremkHPJQCHND78XnXGwi","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>