<!DOCTYPE html><html lang="ko-KR"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:url" content="https://100paperkite.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko-KR"/><meta property="og:site_name" content="Baek Jiyeon"/><title>Node.js 내부 구조 | Baek Jiyeon</title><meta name="robots" content="index,follow"/><meta name="description" content="Node.js 내부 구조에 대해서 알아보기"/><meta property="og:title" content="Node.js 내부 구조 | Baek Jiyeon"/><meta property="og:description" content="Node.js 내부 구조에 대해서 알아보기"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2022-03-03","description":"Node.js 내부 구조에 대해서 알아보기","mainEntityOfPage":{"@type":"WebPage","@id":"https://100paperkite.github.io/posts/Nodejs-내부-구조"},"headline":"Node.js 내부 구조","dateModified":"2022-03-03","author":{"@type":"Person","name":"Baek Jiyeon"}}</script><meta name="next-head-count" content="12"/><script id="gtag-init" strategy="afterInteractive">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-FFSLQ27YMJ', {
                page_path: window.location.pathname,
              });
            </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FFSLQ27YMJ"></script><link rel="preload" href="/_next/static/css/a1248b712b212e8b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1248b712b212e8b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5229e4176ced45f0.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-1b1db7be3343898e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4950b4b931360bc8.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-aee1a03cbb0f41ac.js" defer=""></script><script src="/_next/static/chunks/17007de1-711cf284c97b49d4.js" defer=""></script><script src="/_next/static/chunks/2596-e9cc441945f84dbb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-31ac287c4ff03009.js" defer=""></script><script src="/_next/static/_QqfeWiwal7FspF409Ts_/_buildManifest.js" defer=""></script><script src="/_next/static/_QqfeWiwal7FspF409Ts_/_ssgManifest.js" defer=""></script><script src="/_next/static/_QqfeWiwal7FspF409Ts_/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><nav class="flex justify-between sticky top-0 z-50 space-x-4 py-2"><a class="text-neutral-800 hover:text-neutral-600 md:text-xl font-bold mx-4 md:mx-6 my-1 md:my-2 p-2 " href="/">Baek Jiyeon</a></nav><main class="max-w-[820px] px-4 w-full mx-auto flex-grow font-body"><div class="px-2 md:px-4 py-2 md:py-4"><div class="border-b border-1 mb-4 sm:mb-6 border-dashed border-neutral-300"><div class="flex items-center my-1 md:my-2 gap-x-2"><div class="text-[10px] md:text-xs rounded-full bg-neutral-200 text-neutral-500 font-semibold px-2.5 md:px-3.5 md:py-1">node.js</div></div><h1 class="text-4xl sm:text-[44px] font-extrabold mb-2 sm:mb-4 mt-6 sm:mt-10">Node.js 내부 구조</h1><div class="flex py-2 md:py-3 pl-1 text-neutral-500"><small class="">March 3, 2022<!-- -->에 작성</small></div></div><article class="max-w-none prose prose-neutral prose-sm sm:prose-base md:prose-md"><h2>Node.js?</h2>
<p>Node.js는 JavaScript엔진 중 하나인 Google Chrome V8엔진을 이용해 JavaScript를 브라우저 밖에서 실행 가능하게 해주는 JS Runtime Environment이다.</p>
<ul>
<li>Node.js는 V8엔진을 이용해 JS를 해석한다.</li>
<li>브라우저에서 돌아가지 않기 때문에 <code>window</code>나 <code>document</code>같은 Web API는 사용할 수 없다.</li>
<li>OS위에서 돌아가기 때문에 <code>fs</code>, <code>http</code>가 standard library로 제공된다.</li>
<li>node.js는 V8엔진이 지원하는 기능만 쓸 수 있기 때문에, 모든 JS 기능을 바로 쓰지 못할 수 있다.</li>
</ul>
<h4>JavaScript Engine?</h4>
<p>JavaScript 엔진은 변수, 함수 객체를 저장하는 <strong>Memory Heap</strong>과 함수 호출에 쓰이는 <strong>Call Stack</strong>을 가지고 있으며, JavaScript 코드를 실행하기 위해 machine 코드로 변환하거나 Garbage Collection 등등을 수행한다.</p>
<p>브라우저는 각자 내장된 JS엔진을 사용해 웹 페이지의 JS코드를 해석하는데 브라우저마다 다른 엔진을 사용해 언어를 해석하기 때문에 같은 코드여도 브라우저마다 다른 결과가 나올 수 있다.</p>
<h2>Node.js 계층 구조</h2>
<ul>
<li><strong>Node.js API</strong> : Node.js Application에 쓰이는 JS API</li>
<li><strong>Node.js Standard library</strong> : OS관련 함수들이 포함된다(Timer <code>setTimeout</code>, File System <code>fs</code>, Network Calls <code>http</code>)</li>
<li><strong>V8</strong> : Memory Heap, Call Stack, Garbage Collector로 구성된다 + JS를 OS에 맞는 machine code로 변환한다</li>
<li><strong>libuv</strong> : 비동기 I/O를 지원하는 C언어 library로, 커널의 비동기 API(윈도우- IOCP, 리눅스-AIO)로 지원할 수 없는 작업을 비동기화 하기 위한 <strong>별도의 Thread Pool</strong>(기본 값으로 4개를 사용하도록 설정되어 있음)을 가지고 있고 Event Loop, Event Queue를 관리한다.</li>
<li><strong>c-ares</strong> : <code>dns</code>모듈에 쓰이는 비동기 DNS 요청을 위한 C언어 library</li>
<li><strong>llhttp</strong> : HTTP requeset/response 파싱 (이전엔 <code>http-parsed</code>가 쓰였다)</li>
<li><strong>open-ssl</strong> : 암호화 library (<code>tls</code>, <code>crypto</code>모듈에 쓰인다)</li>
<li><strong>zlib</strong> : 압축/압축 해제 library</li>
</ul>
<blockquote>
<p>Node.js dependencies: <a href="https://nodejs.org/en/docs/meta/topics/dependencies/">Dependencies | Node.js (nodejs.org)</a></p>
</blockquote>
<h2>Node.js 특징</h2>
<ul>
<li><strong>Single Threaded</strong> - locking이 없으므로 프로그램이 덜 복잡해진다</li>
<li><strong>Non-Blocking I/O</strong> - I/O가 끝날 때까지 기다리지 않는다</li>
<li><strong>Asynchronous</strong> - 비동기로 실행한다</li>
</ul>
<p><strong>💡 Single thread임에도 Asynchronous Non-Blocking I/O가 가능한 이유는 Event Loop때문이다.</strong></p>
<ul>
<li>Event loop에서 각 요청에 맞는 kernel의 비동기 함수를 호출하거나, kernel 비동기 함수로 지원되지 않는 작업은 libuv의 thread pool을 이용해 별도의 스레드를 만들어 처리한다.</li>
<li>main thread가 아닌 백그라운드에서 여러 작업을 수행할 수 있다.</li>
</ul>
<p><strong>💡 Multi-thread가 아니기 때문에 CPU를 많이 사용하는 작업에는 적합하지 않고, I/O가 많은 작업에 사용하는 것이 적합하다</strong></p>
<h2>Event Loop</h2>
<figure class="text-center pt-1 sm:pt-2 md:pt-3"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27700%27%20height=%27700%27/%3e"/></span><img alt="nodejs event loop workflow" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="flex rounded" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="nodejs event loop workflow" src="/nodejs-event-loop.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="flex rounded" loading="lazy"/></noscript></span><div><a class="text-xs underline text-neutral-500" href="https://www.voidcanvas.com/nodejs-event-loop/">https://www.voidcanvas.com/nodejs-event-loop/</a></div></figure>
<ul>
<li>
<p><code>node main.js</code>를 콘솔에서 실행시켰을 때, Node.js는 이벤트 루프를 생성한 다음 <strong>이벤트 루프 바깥</strong>에서 메인 모듈인 <code>main.js</code>를 실행한다.</p>
</li>
<li>
<p>한번 메인 모듈이 실행되고나면 Node.js는 이벤트 루프가 활성 상태인지, 즉 이벤트 루프 안에서 해야할 작업이 있는지를 확인한다. 만약 이벤트 루프를 돌릴 필요가 없다면 종료한다.</p>
</li>
<li>
<p>이벤트 루프를 돌려야 한다면 Timer 단계부터 실행된다.</p>
</li>
<li>
<p>육각형이 이벤트 루프의 각 단계를 말하고, 각 단계는 실행할 callback들을 담은 FIFO Queue를 가진다</p>
<ul>
<li>내부의 <code>nextTickQueue</code>, <code>microTaskQueue</code> 는 이벤트 루프의 일부가 아니며 어떤 단계에서든 실행될 수 있고, 가장 높은 우선순위를 지닌다.</li>
<li><code>nextTickQueue</code>에 담긴 작업이 재귀 호출을 수행하는 경우 Node.js의 작업 프로세스를 블록킹할 수 있다.</li>
</ul>
</li>
<li>
<p>이벤트 루프가 해당 단계에 진입하면 해당 단계에 한정된 작업을 수행하고, 큐를 모두 소진하거나 최대 개수의 콜백을 실행할때 까지 콜백을 실행한다. (큐를 모두 소진하거나 콜백 제한에 걸리면 다음 단계로 이동)</p>
</li>
<li>
<p>Call Stack이 비어있으면 이벤트 루프는 큐에서 I/O가 끝난 작업의 콜백을 Call Stack에 넘겨서 실행될 수 있게 한다.</p>
</li>
<li>
<p>이벤트 루프는 루프마다 다른 비동기 I/O나 Timer를 기다려야 하는지 확인하고 기다리는 것이 없다면 깔끔하게 종료한다.</p>
</li>
</ul>
<h3>각 단계</h3>
<h4><strong>timers</strong></h4>
<p><code>setTimeout()</code>과 <code>setInterval()</code>로 스케줄링한 콜백을 실행한다. (min-heap으로 타이머들을 유지한다)</p>
<p>타이머 콜백은 지정한 시간이 지난 후에 스케줄링 될 수 있는 가장 이른시간에 실행된다. (운영체제 스케줄링이나 다른 콜백 실행때문에 지연될 수 있다)</p>
<p>*기술적으로는 poll 단계에서 타이머를 언제 실행할지 제어한다. (poll 큐에 이벤트가 없어야 Timer를 확인한다)</p>
<h4><strong>pending callbacks</strong></h4>
<p>TCP 오류 같은 시스템 작업의 콜백을 실행한다.</p>
<p>ex. 에러 핸들러 콜백</p>
<h4><strong>idle, prepare</strong></h4>
<p>내부용으로만 사용한다.</p>
<h4><strong>poll</strong></h4>
<h5><strong>두 가지 주요 기능</strong></h5>
<ul>
<li>I/O를 얼마나 오래 block하고 polling하는 지 계산한다</li>
<li>그 다음 poll 큐에 있는 이벤트를 처리한다<!-- -->
<ul>
<li>I/O와 연관된 콜백(close callback, Timer callback, <code>setImmediate()</code>를 제외한 거의 모든 콜백이 포함된다)</li>
</ul>
</li>
</ul>
<p>만약 이벤트 루프가 이 단계에 진입하고, <strong>스케줄링된 타이머가 없을때</strong> 두 가지 상황 중 하나가 발생한다.</p>
<ul>
<li>Poll 큐가 <strong>비어있지 않다면</strong> 이벤트 루프가 콜백의 큐를 순회하면서 큐를 다 소진하거나, 시스템에 의존적인 하드 한계에 도달할 때까지 동기로 콜백을 실행한다.</li>
<li>Poll 큐가 <strong>비어있다면</strong> 다음 중 하나의 상황이 발생한다.<!-- -->
<ul>
<li>setImmediate()가 스케줄링되었다면 이벤트 루프는 poll단계를 종료하고 스케줄링된 스크립트를 실행하기 위해 check단계로 넘어간다</li>
<li>setImmediate()가 스케줄링되지 않았다면 이벤트 루프는 콜백이 Poll 큐에 추가되기를 기다린 후 즉시 실행한다</li>
</ul>
</li>
</ul>
<p>+) 단, poll 큐가 일단 비게 되면 타이머가 <strong>시간을 초과했는지</strong> 확인하고, 하나 이상의 타이머가 준비되었다면 이벤트 루프는 타이머의 콜백을 실행하기 위해 timers단계로 돌아간다.</p>
<p>+) 폴링 이벤트를 처리하면서 poll 이벤트를 큐에 추가할 수 있다. 그 결과 오래 실행되는 콜백은 poll 단계가 타이머의 한계 시점보다 훨씬 더 오래 실행되도록 할 수 있다. (단, poll 단계가 이벤트 루프를 모두 차지하면 안되므로 libuv는 최대치를 설정한다)</p>
<h4><strong>check</strong></h4>
<p><code>setImmediate()</code> 콜백을 호출한다.</p>
<h4><strong>close callbacks</strong></h4>
<p><code>socket.on(&#x27;close&#x27;, ...)</code>같은 close 이벤트 타입의 핸들러들을 처리한다.</p>
<h3>setImmediate() vs setTimeout() vs process.nextTick() 실행 순서</h3>
<h4>setImmediate() vs setTimeout()</h4>
<p>비슷하지만 호출된 시기에 따라 다르게 동작한다.</p>
<p><strong>Example 1</strong></p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">setTimeout(() =&gt; {
  console.log(&#x27;setTimeout&#x27;);
}, 0);
setImmediate(() =&gt; {
  console.log(&#x27;setImmediate&#x27;);
});</code></pre>
<p>▲ 뭐가 먼저 출력되는 지 알 수 없다. 이벤트 루프가 Timer 단계에 진입할 때 타이머가 등록되지 않을 수 있기 때문이다(타이머는 메모리에 저장되는데, 그 순간 컴퓨터의 성능이나 Node.js가 아닌 외부 작업 때문에 약간의 딜레이가 발생할 수 있다)</p>
<p><strong>Example 2</strong></p>
<pre style="display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8"><code class="language-javascript">fs.readFile(&#x27;my-file-path.txt&#x27;, () =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;setTimeout&#x27;);
  }, 0);
  setImmediate(() =&gt; {
    console.log(&#x27;setImmediate&#x27;);
  });
});</code></pre>
<p>▲ I/O 주기 내에서 호출하면 <code>setImmediate</code>가 항상 먼저 실행된다. (poll 이후에 바로 check단계에서 setImmediate가 실행되므로. setTimeout은 그 다음 루프의 timers에서 실행된다)</p>
<h4>setImmediate() vs process.nextTick()</h4>
<p>process.nextTick()이 setImmediate()보다 더 즉시 실행된다.</p>
<ul>
<li>process.nextTick(): 한 단계에서 다음 단계로 넘어가는 매 <code>tick</code>마다 최대한 빨리 호출되도록 작동된다.</li>
<li>setImmediate(): 루프가 돌때마다 관리한다.</li>
</ul>
<h2>참고 자료</h2>
<ul>
<li><a href="https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/">Node.js 이벤트 루프, 타이머, `process.nextTick()` | Node.js (nodejs.org)</a></li>
<li><a href="https://www.voidcanvas.com/nodejs-event-loop/">Node.js event loop workflow &amp; lifecycle in low level (voidcanvas.com)</a></li>
<li><a href="https://medium.com/zigbang/nodejs-event-loop%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-16e9290f2b30">NodeJS Event Loop파헤치기</a></li>
<li><a href="https://chathuranga94.medium.com/nodejs-architecture-concurrency-model-f71da5f53d1d">NodeJS Architecture &amp; Concurrency Model | by Udara Bibile | Medium</a></li>
<li><a href="https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/">로우 레벨로 살펴보는 Node.js 이벤트 루프 | Evans Library (evan-moon.github.io)</a></li>
</ul></article><div><hr class="border-t border-neutral-300 my-8 sm:my-16"/><section></section></div></div></main><footer class="font-title py-4 sm:py-8 flex flex-col items-center text-neutral-600"><div class="flex flex-row my-2"><div class="flex items-center py-1"><a class="m-2 " href="https://github.com/100paperkite"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.976 0A7.977 7.977 0 0 0 0 7.976c0 3.522 2.3 6.507 5.431 7.584.392.049.538-.196.538-.392v-1.37c-2.201.49-2.69-1.076-2.69-1.076-.343-.93-.881-1.175-.881-1.175-.734-.489.048-.489.048-.489.783.049 1.224.832 1.224.832.734 1.223 1.859.88 2.3.685.048-.538.293-.88.489-1.076-1.762-.196-3.621-.881-3.621-3.964 0-.88.293-1.566.832-2.153-.05-.147-.343-.978.098-2.055 0 0 .685-.196 2.201.832.636-.196 1.322-.245 2.007-.245s1.37.098 2.006.245c1.517-1.027 2.202-.832 2.202-.832.44 1.077.146 1.908.097 2.104a3.16 3.16 0 0 1 .832 2.153c0 3.083-1.86 3.719-3.62 3.915.293.244.538.733.538 1.467v2.202c0 .196.146.44.538.392A7.984 7.984 0 0 0 16 7.976C15.951 3.572 12.38 0 7.976 0z"></path></svg></a><a class="m-2" href="mailto:100.paperkite@gmail.com"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5l.5-.5h13l.5.5v9l-.5.5h-13l-.5-.5v-9zm1 1.035V12h12V4.536L8.31 8.9H7.7L2 4.535zM13.03 4H2.97L8 7.869 13.03 4z"></path></svg></a></div></div><span class="text-sm md:text-base text-neutral-500">Baek Jiyeon<!-- --> © <!-- -->2022</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"Node.js 내부 구조","description":"Node.js 내부 구조에 대해서 알아보기","uploaded":"2022-03-03","updated":"2022-03-03","tags":["node.js"],"draft":false},"slug":"Nodejs-내부-구조","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      code: \"code\",\n      h4: \"h4\",\n      strong: \"strong\",\n      blockquote: \"blockquote\",\n      a: \"a\",\n      h3: \"h3\",\n      h5: \"h5\",\n      pre: \"pre\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"Node.js?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Node.js는 JavaScript엔진 중 하나인 Google Chrome V8엔진을 이용해 JavaScript를 브라우저 밖에서 실행 가능하게 해주는 JS Runtime Environment이다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Node.js는 V8엔진을 이용해 JS를 해석한다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"브라우저에서 돌아가지 않기 때문에 \", _jsx(_components.code, {\n            children: \"window\"\n          }), \"나 \", _jsx(_components.code, {\n            children: \"document\"\n          }), \"같은 Web API는 사용할 수 없다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"OS위에서 돌아가기 때문에 \", _jsx(_components.code, {\n            children: \"fs\"\n          }), \", \", _jsx(_components.code, {\n            children: \"http\"\n          }), \"가 standard library로 제공된다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"node.js는 V8엔진이 지원하는 기능만 쓸 수 있기 때문에, 모든 JS 기능을 바로 쓰지 못할 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"JavaScript Engine?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"JavaScript 엔진은 변수, 함수 객체를 저장하는 \", _jsx(_components.strong, {\n          children: \"Memory Heap\"\n        }), \"과 함수 호출에 쓰이는 \", _jsx(_components.strong, {\n          children: \"Call Stack\"\n        }), \"을 가지고 있으며, JavaScript 코드를 실행하기 위해 machine 코드로 변환하거나 Garbage Collection 등등을 수행한다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"브라우저는 각자 내장된 JS엔진을 사용해 웹 페이지의 JS코드를 해석하는데 브라우저마다 다른 엔진을 사용해 언어를 해석하기 때문에 같은 코드여도 브라우저마다 다른 결과가 나올 수 있다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Node.js 계층 구조\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Node.js API\"\n          }), \" : Node.js Application에 쓰이는 JS API\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Node.js Standard library\"\n          }), \" : OS관련 함수들이 포함된다(Timer \", _jsx(_components.code, {\n            children: \"setTimeout\"\n          }), \", File System \", _jsx(_components.code, {\n            children: \"fs\"\n          }), \", Network Calls \", _jsx(_components.code, {\n            children: \"http\"\n          }), \")\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"V8\"\n          }), \" : Memory Heap, Call Stack, Garbage Collector로 구성된다 + JS를 OS에 맞는 machine code로 변환한다\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"libuv\"\n          }), \" : 비동기 I/O를 지원하는 C언어 library로, 커널의 비동기 API(윈도우- IOCP, 리눅스-AIO)로 지원할 수 없는 작업을 비동기화 하기 위한 \", _jsx(_components.strong, {\n            children: \"별도의 Thread Pool\"\n          }), \"(기본 값으로 4개를 사용하도록 설정되어 있음)을 가지고 있고 Event Loop, Event Queue를 관리한다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"c-ares\"\n          }), \" : \", _jsx(_components.code, {\n            children: \"dns\"\n          }), \"모듈에 쓰이는 비동기 DNS 요청을 위한 C언어 library\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"llhttp\"\n          }), \" : HTTP requeset/response 파싱 (이전엔 \", _jsx(_components.code, {\n            children: \"http-parsed\"\n          }), \"가 쓰였다)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"open-ssl\"\n          }), \" : 암호화 library (\", _jsx(_components.code, {\n            children: \"tls\"\n          }), \", \", _jsx(_components.code, {\n            children: \"crypto\"\n          }), \"모듈에 쓰인다)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"zlib\"\n          }), \" : 압축/압축 해제 library\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Node.js dependencies: \", _jsx(_components.a, {\n            href: \"https://nodejs.org/en/docs/meta/topics/dependencies/\",\n            children: \"Dependencies | Node.js (nodejs.org)\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Node.js 특징\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Single Threaded\"\n          }), \" - locking이 없으므로 프로그램이 덜 복잡해진다\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Non-Blocking I/O\"\n          }), \" - I/O가 끝날 때까지 기다리지 않는다\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Asynchronous\"\n          }), \" - 비동기로 실행한다\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"💡 Single thread임에도 Asynchronous Non-Blocking I/O가 가능한 이유는 Event Loop때문이다.\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Event loop에서 각 요청에 맞는 kernel의 비동기 함수를 호출하거나, kernel 비동기 함수로 지원되지 않는 작업은 libuv의 thread pool을 이용해 별도의 스레드를 만들어 처리한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"main thread가 아닌 백그라운드에서 여러 작업을 수행할 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"💡 Multi-thread가 아니기 때문에 CPU를 많이 사용하는 작업에는 적합하지 않고, I/O가 많은 작업에 사용하는 것이 적합하다\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Event Loop\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/nodejs-event-loop.png\",\n        alt: \"nodejs event loop workflow\",\n        sourceHref: \"https://www.voidcanvas.com/nodejs-event-loop/\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.code, {\n              children: \"node main.js\"\n            }), \"를 콘솔에서 실행시켰을 때, Node.js는 이벤트 루프를 생성한 다음 \", _jsx(_components.strong, {\n              children: \"이벤트 루프 바깥\"\n            }), \"에서 메인 모듈인 \", _jsx(_components.code, {\n              children: \"main.js\"\n            }), \"를 실행한다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"한번 메인 모듈이 실행되고나면 Node.js는 이벤트 루프가 활성 상태인지, 즉 이벤트 루프 안에서 해야할 작업이 있는지를 확인한다. 만약 이벤트 루프를 돌릴 필요가 없다면 종료한다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"이벤트 루프를 돌려야 한다면 Timer 단계부터 실행된다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"육각형이 이벤트 루프의 각 단계를 말하고, 각 단계는 실행할 callback들을 담은 FIFO Queue를 가진다\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"내부의 \", _jsx(_components.code, {\n                children: \"nextTickQueue\"\n              }), \", \", _jsx(_components.code, {\n                children: \"microTaskQueue\"\n              }), \" 는 이벤트 루프의 일부가 아니며 어떤 단계에서든 실행될 수 있고, 가장 높은 우선순위를 지닌다.\"]\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [_jsx(_components.code, {\n                children: \"nextTickQueue\"\n              }), \"에 담긴 작업이 재귀 호출을 수행하는 경우 Node.js의 작업 프로세스를 블록킹할 수 있다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"이벤트 루프가 해당 단계에 진입하면 해당 단계에 한정된 작업을 수행하고, 큐를 모두 소진하거나 최대 개수의 콜백을 실행할때 까지 콜백을 실행한다. (큐를 모두 소진하거나 콜백 제한에 걸리면 다음 단계로 이동)\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Call Stack이 비어있으면 이벤트 루프는 큐에서 I/O가 끝난 작업의 콜백을 Call Stack에 넘겨서 실행될 수 있게 한다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"이벤트 루프는 루프마다 다른 비동기 I/O나 Timer를 기다려야 하는지 확인하고 기다리는 것이 없다면 깔끔하게 종료한다.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"각 단계\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"timers\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"setTimeout()\"\n        }), \"과 \", _jsx(_components.code, {\n          children: \"setInterval()\"\n        }), \"로 스케줄링한 콜백을 실행한다. (min-heap으로 타이머들을 유지한다)\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"타이머 콜백은 지정한 시간이 지난 후에 스케줄링 될 수 있는 가장 이른시간에 실행된다. (운영체제 스케줄링이나 다른 콜백 실행때문에 지연될 수 있다)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"*기술적으로는 poll 단계에서 타이머를 언제 실행할지 제어한다. (poll 큐에 이벤트가 없어야 Timer를 확인한다)\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"pending callbacks\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"TCP 오류 같은 시스템 작업의 콜백을 실행한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"ex. 에러 핸들러 콜백\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"idle, prepare\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"내부용으로만 사용한다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"poll\"\n        })\n      }), \"\\n\", _jsx(_components.h5, {\n        children: _jsx(_components.strong, {\n          children: \"두 가지 주요 기능\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"I/O를 얼마나 오래 block하고 polling하는 지 계산한다\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"그 다음 poll 큐에 있는 이벤트를 처리한다\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"I/O와 연관된 콜백(close callback, Timer callback, \", _jsx(_components.code, {\n                children: \"setImmediate()\"\n              }), \"를 제외한 거의 모든 콜백이 포함된다)\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"만약 이벤트 루프가 이 단계에 진입하고, \", _jsx(_components.strong, {\n          children: \"스케줄링된 타이머가 없을때\"\n        }), \" 두 가지 상황 중 하나가 발생한다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Poll 큐가 \", _jsx(_components.strong, {\n            children: \"비어있지 않다면\"\n          }), \" 이벤트 루프가 콜백의 큐를 순회하면서 큐를 다 소진하거나, 시스템에 의존적인 하드 한계에 도달할 때까지 동기로 콜백을 실행한다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Poll 큐가 \", _jsx(_components.strong, {\n            children: \"비어있다면\"\n          }), \" 다음 중 하나의 상황이 발생한다.\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"setImmediate()가 스케줄링되었다면 이벤트 루프는 poll단계를 종료하고 스케줄링된 스크립트를 실행하기 위해 check단계로 넘어간다\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"setImmediate()가 스케줄링되지 않았다면 이벤트 루프는 콜백이 Poll 큐에 추가되기를 기다린 후 즉시 실행한다\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"+) 단, poll 큐가 일단 비게 되면 타이머가 \", _jsx(_components.strong, {\n          children: \"시간을 초과했는지\"\n        }), \" 확인하고, 하나 이상의 타이머가 준비되었다면 이벤트 루프는 타이머의 콜백을 실행하기 위해 timers단계로 돌아간다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"+) 폴링 이벤트를 처리하면서 poll 이벤트를 큐에 추가할 수 있다. 그 결과 오래 실행되는 콜백은 poll 단계가 타이머의 한계 시점보다 훨씬 더 오래 실행되도록 할 수 있다. (단, poll 단계가 이벤트 루프를 모두 차지하면 안되므로 libuv는 최대치를 설정한다)\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"check\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"setImmediate()\"\n        }), \" 콜백을 호출한다.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: _jsx(_components.strong, {\n          children: \"close callbacks\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"socket.on('close', ...)\"\n        }), \"같은 close 이벤트 타입의 핸들러들을 처리한다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"setImmediate() vs setTimeout() vs process.nextTick() 실행 순서\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"setImmediate() vs setTimeout()\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"비슷하지만 호출된 시기에 따라 다르게 동작한다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Example 1\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"setTimeout(() =\u003e {\\n  console.log('setTimeout');\\n}, 0);\\nsetImmediate(() =\u003e {\\n  console.log('setImmediate');\\n});\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"▲ 뭐가 먼저 출력되는 지 알 수 없다. 이벤트 루프가 Timer 단계에 진입할 때 타이머가 등록되지 않을 수 있기 때문이다(타이머는 메모리에 저장되는데, 그 순간 컴퓨터의 성능이나 Node.js가 아닌 외부 작업 때문에 약간의 딜레이가 발생할 수 있다)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Example 2\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"fs.readFile('my-file-path.txt', () =\u003e {\\n  setTimeout(() =\u003e {\\n    console.log('setTimeout');\\n  }, 0);\\n  setImmediate(() =\u003e {\\n    console.log('setImmediate');\\n  });\\n});\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"▲ I/O 주기 내에서 호출하면 \", _jsx(_components.code, {\n          children: \"setImmediate\"\n        }), \"가 항상 먼저 실행된다. (poll 이후에 바로 check단계에서 setImmediate가 실행되므로. setTimeout은 그 다음 루프의 timers에서 실행된다)\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"setImmediate() vs process.nextTick()\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"process.nextTick()이 setImmediate()보다 더 즉시 실행된다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"process.nextTick(): 한 단계에서 다음 단계로 넘어가는 매 \", _jsx(_components.code, {\n            children: \"tick\"\n          }), \"마다 최대한 빨리 호출되도록 작동된다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"setImmediate(): 루프가 돌때마다 관리한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"참고 자료\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/\",\n            children: \"Node.js 이벤트 루프, 타이머, `process.nextTick()` | Node.js (nodejs.org)\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://www.voidcanvas.com/nodejs-event-loop/\",\n            children: \"Node.js event loop workflow \u0026 lifecycle in low level (voidcanvas.com)\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://medium.com/zigbang/nodejs-event-loop%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-16e9290f2b30\",\n            children: \"NodeJS Event Loop파헤치기\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://chathuranga94.medium.com/nodejs-architecture-concurrency-model-f71da5f53d1d\",\n            children: \"NodeJS Architecture \u0026 Concurrency Model | by Udara Bibile | Medium\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/\",\n            children: \"로우 레벨로 살펴보는 Node.js 이벤트 루프 | Evans Library (evan-moon.github.io)\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Nodejs-내부-구조"},"buildId":"_QqfeWiwal7FspF409Ts_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>