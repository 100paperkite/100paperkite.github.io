<!DOCTYPE html><html lang="ko-KR"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:url" content="https://100paperkite.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko-KR"/><meta property="og:site_name" content="paperkite.log 👋"/><title>[책] 대규모 서비스를 지탱하는 기술 | paperkite.log 👋</title><meta name="robots" content="index,follow"/><meta name="description" content="[책] 대규모 서비스를 지탱하는 기술"/><meta property="og:title" content="[책] 대규모 서비스를 지탱하는 기술 | paperkite.log 👋"/><meta property="og:description" content="[책] 대규모 서비스를 지탱하는 기술"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2022-12-29","description":"[책] 대규모 서비스를 지탱하는 기술","mainEntityOfPage":{"@type":"WebPage","@id":"https://100paperkite.github.io/posts/book-large-scale-service-tech"},"headline":"[책] 대규모 서비스를 지탱하는 기술","dateModified":"2022-12-29","author":{"@type":"Person","name":"100paperkite"}}</script><meta name="next-head-count" content="12"/><script id="gtag-init" strategy="afterInteractive">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-FFSLQ27YMJ', {
                page_path: window.location.pathname,
              });
            </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FFSLQ27YMJ"></script><link rel="preload" href="/_next/static/css/a1fed7b6ed75c1ba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1fed7b6ed75c1ba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2b9c97c898ba3e9b.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-1b1db7be3343898e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c1e739f18573092f.js" defer=""></script><script src="/_next/static/chunks/1bfc9850-6dd5619a8decfbcd.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-aee1a03cbb0f41ac.js" defer=""></script><script src="/_next/static/chunks/17007de1-711cf284c97b49d4.js" defer=""></script><script src="/_next/static/chunks/5386-42957cb47b98ece3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e8ce3b8529fbe652.js" defer=""></script><script src="/_next/static/ynA6RsHmsr1Q1bci33Ez5/_buildManifest.js" defer=""></script><script src="/_next/static/ynA6RsHmsr1Q1bci33Ez5/_ssgManifest.js" defer=""></script><script src="/_next/static/ynA6RsHmsr1Q1bci33Ez5/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><nav class="flex justify-between sticky top-0 z-50 space-x-4 py-2 font-medium mx-2 md:mx-6 my-1 md:my-2 p-2"><a class="text-neutral-800 hover:text-neutral-600 text-lg md:text-xl" href="/">paperkite.log 👋</a><div class="flex gap-x-3"><a href="/tags"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" class="hover:cursor-pointer w-6 h-6 text-neutral-700" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg></a></div></nav><main class="max-w-screen-md px-4 w-full mx-auto flex-grow font-body"><div class="px-2 md:px-4 py-2 md:py-4"><div class="border-b border-1 mb-4 sm:mb-6 border-dashed border-neutral-300"><div class="flex items-center my-1 md:my-2 gap-x-2"><button class="text-neutral-500 font-bold">#책</button></div><h1 class="text-3xl sm:text-4xl font-bold mb-2 sm:mb-4 mt-6 sm:mt-10">[책] 대규모 서비스를 지탱하는 기술</h1><div class="flex py-2 md:py-3 pl-1 text-neutral-500"><small class="">December 29, 2022<!-- -->에 작성</small><small class=""> · <!-- -->January 1, 1970<!-- -->에 변경됨</small></div></div><article class="max-w-none prose prose-neutral sm:prose-h1:text-[2.5rem] sm:prose-h2:text-[2rem] sm:prose-h3:text-2xl sm:prose-h4:text-xl"><h2>대규모 데이터는 어떤 점이 어려운가?</h2>
<ul>
<li>메모리 내에서 계산할 수 없다.</li>
<li>메모리 내에서 계산할 수 없게 되면 디스크에서 데이터를 검색해야 한다.</li>
<li>하지만 디스크의 I/O는 메모리보다 느리므로 이를 어떻게 대처하는지가 어려운 점이다.</li>
</ul>
<h2>디스크가 느린 이유?</h2>
<h3>읽는 속도</h3>
<ul>
<li>(SSD가 아닌) 원반형의 HDD는 원반을 읽는 헤드가 <strong>물리적으로</strong> 돌아가면서 데이터를 읽게 된다.</li>
<li>따라서 데이터의 위치까지 헤드를 옮기는 시간, 헤드를 회전시키면서 읽는 시간 등이 소요되게 된다.</li>
<li>읽어야 하는 데이터가 여기저기 분산되어 있다면 읽는시간이 더 오래걸리게 된다. (따라서OS 차원에서는 이를 보완하기 위해 데이터를 보통 4KB단위의 블록으로 구분해서 저장한다)</li>
</ul>
<h3>전송 속도</h3>
<ul>
<li>메모리와 디스크는 CPU와 버스로 연결되어 있는데</li>
<li>메모리 ↔ CPU의 버스는 높은 대역폭의 버스로 연결되어 있고, 디스크 ↔ CPU는 비교적 낮은 대역폭의 버스로 연결되어 있다.</li>
</ul>
<p>따라서 디스크에서 데이터를 가져오는 것은 메모리에서 가져오는 것 보다 항상 느리다. <small>(책에서는 메모리는 디스크보다 10<sup>5</sup> ~ 10<sup>6</sup>배 이상 빠르다고 한다.)</small></p>
<h2>시스템 확장성</h2>
<ul>
<li>서버에서 부하로 인해 처리 속도가 낮아지면 시스템을 확장해야 한다.</li>
<li>확장 방법에는 scale out(서버 대수를 늘리기)과 scale up(서버 성능을 높이기) 두 가지가 있다.</li>
<li>주로 저렴하고 확장에 유연하기 때문에 scale out 방법을 많이 쓴다.</li>
</ul>
<h3>부하</h3>
<p>부하에는 두 가지 종류가 있다.</p>
<ul>
<li>CPU 부하 → 어플리케이션 서버에서 많은 계산을 수행하는 경우</li>
<li>I/O 부하 → 디스크 입출력이 많은 경우. DB에 걸리는 부하</li>
</ul>
<h2>DB 확장성 확보의 어려움</h2>
<ul>
<li>어플리케이션 서버는 주로 CPU 계산만 수행하기 때문에 대수를 늘려서 확장하기 쉽지만 DB는 그렇지 않다.</li>
<li>여러 대의 DB를 둔다고 했을 때, 한 DB에 쓴 데이터를 다른 DB들에 어떻게 동기화 해야 하는지부터 문제가 생긴다.</li>
</ul>
<h2>DB 분산하기</h2>
<p>메모리 증설만으로는 부하 감당이 불가능하다면 DB를 파티셔닝 해야한다. 파티셔닝은 국소성을 활용해서 분산할 수 있으므로 캐시가 유효하고, 그래서 파티셔닝은 효과적일 수 있다.</p>
<h3>국소성(locality)을 고려하기</h3>
<ul>
<li>DB 테이블 단위로 파티셔닝</li>
<li>요청 유형에 따라 파티셔닝<!-- -->
<ul>
<li>ex. bot인지 일반 사용자인지</li>
</ul>
</li>
</ul>
<h3>분산을 고려한 MySQL 운용방법</h3>
<ol>
<li>
<h4>OS 캐시 활용하기</h4>
<ul>
<li>데이터량 &lt; 물리 메모리 유지.</li>
<li>대량의 데이터를 저장하게 되면 조금의 스키마를 변경하는 것 만으로도 데이터가 기가바이트 단위로 증가할 수 있다.</li>
<li>대량의 데이터를 저장하려는 테이블은 레코드가 가능한 작아지도록 컴팩트하게 설계.</li>
</ul>
</li>
<li>
<h4>정규화</h4>
<ul>
<li>정규화를 하면 테이블 용량이 줄어서 좋을 수 있지만</li>
<li>경우에 따라서는 오히려 쿼리가 복잡해서 속도가 떨어질 수 있으므로 trade-off를 고려해야 한다.</li>
</ul>
</li>
<li>
<h4>DB 인덱스 적절하게 설정하기</h4>
<ul>
<li>MySQL의 인덱스는 기본적으로 B+트리 구조 (탐색속도 O(logn)) 이므로 선형 탐색보다 월등히 빠르다.</li>
</ul>
</li>
<li>
<h4>확장을 전제로 설계하기</h4>
<ul>
<li>읽기 &gt; 쓰기: <strong>레플리케이션</strong>(Replication)<!-- -->
<ul>
<li>DB들을 Master-Slave로 구분해서 쓰기는 Master에, 읽기는 Slave에서 하는 것.</li>
<li>Master에 쓰면 Slave가 동일한 내용으로 자신을 갱신한다.<!-- -->
<ul>
<li>참고) 마스터-슬레이브의 다중화 방법<!-- -->
<ul>
<li>4개 이상이 한 세트이다.</li>
<li>슬레이브가 하나 고장나면 다른 하나의 슬레이브를 중지시키고 새 서버에 복사해야 하므로 슬레이브가 3개 이상 필요하다.</li>
<li>마스터가 고장나면 슬레이브 중 하나를 마스터로 승격시킨다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>읽기 &lt; 쓰기 라면<!-- -->
<ul>
<li>테이블을 분할해서 쓰기 작업을 분산</li>
<li>RDBMS 대신 Key-Value 저장소 사용하기<!-- -->
<ul>
<li>단순히 값을 저장하고 꺼내므로, RDMBS의 스키마 검사, 정렬 처리 등의 오버헤드가 전혀 발생하지 않아 빠르다.</li>
</ul>
</li>
</ul>
</li>
<li>서로 JOIN하는 테이블은 분산하지 말 것.<!-- -->
<ul>
<li>딘, MySQL 5.1 부터는 다른 머신의 테이블과 JOIN할 수 있는 FEDERATE 기능이 존재.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>파티셔닝의 단점</h3>
<ul>
<li>어디에 어떤 테이블이 있는지를 확인해야 하므로 운영이 복잡해진다.</li>
<li>대수가 늘어나므로 고장률이 높아진다.</li>
</ul>
<h2>스토리지 선택하기</h2>
<h3>스토리지 선택의 전제 조건</h3>
<ul>
<li>어플리케이션의 액세스 패턴을 이해하기<!-- -->
<ul>
<li>평균 크기</li>
<li>최대 크기</li>
<li>신규 추가 빈도</li>
<li>갱신 빈도</li>
<li>삭제 빈도</li>
<li>참조 빈도</li>
<li>신뢰성</li>
<li>허용할 수 있는 장애 레벨</li>
</ul>
</li>
</ul>
<h2>웹 어플리케이션의 프록시/캐시 시스템</h2>
<ul>
<li>포워드(Forward) 프록시<!-- -->
<ul>
<li>클라이언트가 외부 네트워크에 접근할 때 경유.</li>
<li>클라이언트를 외부에 숨긴다.</li>
</ul>
</li>
<li>리버스(Reverse) 프록시<!-- -->
<ul>
<li>애플리케이션 서버 앞단에 두는 것.</li>
<li>클라이언트에게 서버를 숨긴다.</li>
</ul>
</li>
</ul>
<h2>📖 소감</h2>
<p>2011년에 나온 꽤 오래된 책이라 요즘에는 안쓰는 옛날 지식을 다루고 있을 지 걱정했지만, 기본적인 내용들을 다루고 있어서 문제되지 않았다..! 대규모 웹 서비스에서는 어떤 고민을 하는지에 대해 폭넓게 알 수 있는 좋은 계기.</p>
<h2>도서 링크</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/4667932">http://www.yes24.com/Product/Goods/4667932</a></li>
</ul></article><div><hr class="border-t border-neutral-300 my-8 sm:my-16"/><section></section></div></div></main><footer class="font-title py-4 sm:py-8 flex flex-col items-center text-neutral-600"><div class="flex flex-row my-2"><div class="flex items-center py-1"><a class="m-2 " href="https://github.com/100paperkite"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.976 0A7.977 7.977 0 0 0 0 7.976c0 3.522 2.3 6.507 5.431 7.584.392.049.538-.196.538-.392v-1.37c-2.201.49-2.69-1.076-2.69-1.076-.343-.93-.881-1.175-.881-1.175-.734-.489.048-.489.048-.489.783.049 1.224.832 1.224.832.734 1.223 1.859.88 2.3.685.048-.538.293-.88.489-1.076-1.762-.196-3.621-.881-3.621-3.964 0-.88.293-1.566.832-2.153-.05-.147-.343-.978.098-2.055 0 0 .685-.196 2.201.832.636-.196 1.322-.245 2.007-.245s1.37.098 2.006.245c1.517-1.027 2.202-.832 2.202-.832.44 1.077.146 1.908.097 2.104a3.16 3.16 0 0 1 .832 2.153c0 3.083-1.86 3.719-3.62 3.915.293.244.538.733.538 1.467v2.202c0 .196.146.44.538.392A7.984 7.984 0 0 0 16 7.976C15.951 3.572 12.38 0 7.976 0z"></path></svg></a><a class="m-2" href="mailto:100.paperkite@gmail.com"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5l.5-.5h13l.5.5v9l-.5.5h-13l-.5-.5v-9zm1 1.035V12h12V4.536L8.31 8.9H7.7L2 4.535zM13.03 4H2.97L8 7.869 13.03 4z"></path></svg></a></div></div><span class="text-sm text-neutral-500">100paperkite<!-- --> © <!-- -->2023</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"[책] 대규모 서비스를 지탱하는 기술","description":null,"uploaded":"2022-12-29","updated":null,"tags":["책"],"draft":false},"slug":"book-large-scale-service-tech","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\",\n      h3: \"h3\",\n      strong: \"strong\",\n      p: \"p\",\n      ol: \"ol\",\n      h4: \"h4\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"대규모 데이터는 어떤 점이 어려운가?\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"메모리 내에서 계산할 수 없다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"메모리 내에서 계산할 수 없게 되면 디스크에서 데이터를 검색해야 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"하지만 디스크의 I/O는 메모리보다 느리므로 이를 어떻게 대처하는지가 어려운 점이다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"디스크가 느린 이유?\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"읽는 속도\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"(SSD가 아닌) 원반형의 HDD는 원반을 읽는 헤드가 \", _jsx(_components.strong, {\n            children: \"물리적으로\"\n          }), \" 돌아가면서 데이터를 읽게 된다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"따라서 데이터의 위치까지 헤드를 옮기는 시간, 헤드를 회전시키면서 읽는 시간 등이 소요되게 된다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"읽어야 하는 데이터가 여기저기 분산되어 있다면 읽는시간이 더 오래걸리게 된다. (따라서OS 차원에서는 이를 보완하기 위해 데이터를 보통 4KB단위의 블록으로 구분해서 저장한다)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"전송 속도\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"메모리와 디스크는 CPU와 버스로 연결되어 있는데\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"메모리 ↔ CPU의 버스는 높은 대역폭의 버스로 연결되어 있고, 디스크 ↔ CPU는 비교적 낮은 대역폭의 버스로 연결되어 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"따라서 디스크에서 데이터를 가져오는 것은 메모리에서 가져오는 것 보다 항상 느리다. \", _jsxs(\"small\", {\n          children: [\"(책에서는 메모리는 디스크보다 10\", _jsx(\"sup\", {\n            children: \"5\"\n          }), \" ~ 10\", _jsx(\"sup\", {\n            children: \"6\"\n          }), \"배 이상 빠르다고 한다.)\"]\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"시스템 확장성\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"서버에서 부하로 인해 처리 속도가 낮아지면 시스템을 확장해야 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"확장 방법에는 scale out(서버 대수를 늘리기)과 scale up(서버 성능을 높이기) 두 가지가 있다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"주로 저렴하고 확장에 유연하기 때문에 scale out 방법을 많이 쓴다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"부하\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"부하에는 두 가지 종류가 있다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"CPU 부하 → 어플리케이션 서버에서 많은 계산을 수행하는 경우\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"I/O 부하 → 디스크 입출력이 많은 경우. DB에 걸리는 부하\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"DB 확장성 확보의 어려움\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"어플리케이션 서버는 주로 CPU 계산만 수행하기 때문에 대수를 늘려서 확장하기 쉽지만 DB는 그렇지 않다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"여러 대의 DB를 둔다고 했을 때, 한 DB에 쓴 데이터를 다른 DB들에 어떻게 동기화 해야 하는지부터 문제가 생긴다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"DB 분산하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"메모리 증설만으로는 부하 감당이 불가능하다면 DB를 파티셔닝 해야한다. 파티셔닝은 국소성을 활용해서 분산할 수 있으므로 캐시가 유효하고, 그래서 파티셔닝은 효과적일 수 있다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"국소성(locality)을 고려하기\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"DB 테이블 단위로 파티셔닝\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"요청 유형에 따라 파티셔닝\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"ex. bot인지 일반 사용자인지\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"분산을 고려한 MySQL 운용방법\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.h4, {\n            children: \"OS 캐시 활용하기\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"데이터량 \u003c 물리 메모리 유지.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"대량의 데이터를 저장하게 되면 조금의 스키마를 변경하는 것 만으로도 데이터가 기가바이트 단위로 증가할 수 있다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"대량의 데이터를 저장하려는 테이블은 레코드가 가능한 작아지도록 컴팩트하게 설계.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.h4, {\n            children: \"정규화\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"정규화를 하면 테이블 용량이 줄어서 좋을 수 있지만\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"경우에 따라서는 오히려 쿼리가 복잡해서 속도가 떨어질 수 있으므로 trade-off를 고려해야 한다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.h4, {\n            children: \"DB 인덱스 적절하게 설정하기\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"MySQL의 인덱스는 기본적으로 B+트리 구조 (탐색속도 O(logn)) 이므로 선형 탐색보다 월등히 빠르다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.h4, {\n            children: \"확장을 전제로 설계하기\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"읽기 \u003e 쓰기: \", _jsx(_components.strong, {\n                children: \"레플리케이션\"\n              }), \"(Replication)\", \"\\n\", _jsxs(_components.ul, {\n                children: [\"\\n\", _jsx(_components.li, {\n                  children: \"DB들을 Master-Slave로 구분해서 쓰기는 Master에, 읽기는 Slave에서 하는 것.\"\n                }), \"\\n\", _jsxs(_components.li, {\n                  children: [\"Master에 쓰면 Slave가 동일한 내용으로 자신을 갱신한다.\", \"\\n\", _jsxs(_components.ul, {\n                    children: [\"\\n\", _jsxs(_components.li, {\n                      children: [\"참고) 마스터-슬레이브의 다중화 방법\", \"\\n\", _jsxs(_components.ul, {\n                        children: [\"\\n\", _jsx(_components.li, {\n                          children: \"4개 이상이 한 세트이다.\"\n                        }), \"\\n\", _jsx(_components.li, {\n                          children: \"슬레이브가 하나 고장나면 다른 하나의 슬레이브를 중지시키고 새 서버에 복사해야 하므로 슬레이브가 3개 이상 필요하다.\"\n                        }), \"\\n\", _jsx(_components.li, {\n                          children: \"마스터가 고장나면 슬레이브 중 하나를 마스터로 승격시킨다.\"\n                        }), \"\\n\"]\n                      }), \"\\n\"]\n                    }), \"\\n\"]\n                  }), \"\\n\"]\n                }), \"\\n\"]\n              }), \"\\n\"]\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"읽기 \u003c 쓰기 라면\", \"\\n\", _jsxs(_components.ul, {\n                children: [\"\\n\", _jsx(_components.li, {\n                  children: \"테이블을 분할해서 쓰기 작업을 분산\"\n                }), \"\\n\", _jsxs(_components.li, {\n                  children: [\"RDBMS 대신 Key-Value 저장소 사용하기\", \"\\n\", _jsxs(_components.ul, {\n                    children: [\"\\n\", _jsx(_components.li, {\n                      children: \"단순히 값을 저장하고 꺼내므로, RDMBS의 스키마 검사, 정렬 처리 등의 오버헤드가 전혀 발생하지 않아 빠르다.\"\n                    }), \"\\n\"]\n                  }), \"\\n\"]\n                }), \"\\n\"]\n              }), \"\\n\"]\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"서로 JOIN하는 테이블은 분산하지 말 것.\", \"\\n\", _jsxs(_components.ul, {\n                children: [\"\\n\", _jsx(_components.li, {\n                  children: \"딘, MySQL 5.1 부터는 다른 머신의 테이블과 JOIN할 수 있는 FEDERATE 기능이 존재.\"\n                }), \"\\n\"]\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"파티셔닝의 단점\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"어디에 어떤 테이블이 있는지를 확인해야 하므로 운영이 복잡해진다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"대수가 늘어나므로 고장률이 높아진다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"스토리지 선택하기\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"스토리지 선택의 전제 조건\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"어플리케이션의 액세스 패턴을 이해하기\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"평균 크기\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"최대 크기\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"신규 추가 빈도\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"갱신 빈도\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"삭제 빈도\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"참조 빈도\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"신뢰성\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"허용할 수 있는 장애 레벨\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"웹 어플리케이션의 프록시/캐시 시스템\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"포워드(Forward) 프록시\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"클라이언트가 외부 네트워크에 접근할 때 경유.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"클라이언트를 외부에 숨긴다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"리버스(Reverse) 프록시\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"애플리케이션 서버 앞단에 두는 것.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"클라이언트에게 서버를 숨긴다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"📖 소감\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"2011년에 나온 꽤 오래된 책이라 요즘에는 안쓰는 옛날 지식을 다루고 있을 지 걱정했지만, 기본적인 내용들을 다루고 있어서 문제되지 않았다..! 대규모 웹 서비스에서는 어떤 고민을 하는지에 대해 폭넓게 알 수 있는 좋은 계기.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"도서 링크\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"http://www.yes24.com/Product/Goods/4667932\",\n            children: \"http://www.yes24.com/Product/Goods/4667932\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"book-large-scale-service-tech"},"buildId":"ynA6RsHmsr1Q1bci33Ez5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>