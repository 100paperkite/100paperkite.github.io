<!DOCTYPE html><html lang="ko-KR"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:url" content="https://100paperkite.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko-KR"/><meta property="og:site_name" content="paperkite.log 👋"/><title>[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기 | paperkite.log 👋</title><meta name="robots" content="index,follow"/><meta name="description" content="[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기"/><meta property="og:title" content="[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기 | paperkite.log 👋"/><meta property="og:description" content="[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2023-03-03T09:41:29.368Z","description":"[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기","mainEntityOfPage":{"@type":"WebPage","@id":"https://100paperkite.github.io/posts/github-aws-ci-cd"},"headline":"[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기","dateModified":"2023-03-03T09:41:29.368Z","author":{"@type":"Person","name":"100paperkite"}}</script><meta name="next-head-count" content="12"/><script id="gtag-init" strategy="afterInteractive">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-FFSLQ27YMJ', {
                page_path: window.location.pathname,
              });
            </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FFSLQ27YMJ"></script><link rel="preload" href="/_next/static/css/a1fed7b6ed75c1ba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1fed7b6ed75c1ba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2b9c97c898ba3e9b.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-1b1db7be3343898e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c1e739f18573092f.js" defer=""></script><script src="/_next/static/chunks/1bfc9850-6dd5619a8decfbcd.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-aee1a03cbb0f41ac.js" defer=""></script><script src="/_next/static/chunks/17007de1-711cf284c97b49d4.js" defer=""></script><script src="/_next/static/chunks/5386-42957cb47b98ece3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e8ce3b8529fbe652.js" defer=""></script><script src="/_next/static/0xQjpLb5yay7gfVz4gblO/_buildManifest.js" defer=""></script><script src="/_next/static/0xQjpLb5yay7gfVz4gblO/_ssgManifest.js" defer=""></script><script src="/_next/static/0xQjpLb5yay7gfVz4gblO/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><nav class="flex justify-between sticky top-0 z-50 space-x-4 py-2 font-medium mx-2 md:mx-6 my-1 md:my-2 p-2"><a class="text-neutral-800 hover:text-neutral-600 text-lg md:text-xl" href="/">paperkite.log 👋</a><div class="flex gap-x-3"><a href="/tags"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" class="hover:cursor-pointer w-6 h-6 text-neutral-700" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg></a></div></nav><main class="max-w-screen-md px-4 w-full mx-auto flex-grow font-body"><div class="px-2 md:px-4 py-2 md:py-4"><div class="border-b border-1 mb-4 sm:mb-6 border-dashed border-neutral-300"><div class="flex items-center my-1 md:my-2 gap-x-2"><button class="text-neutral-500 font-bold">#ci/cd</button><button class="text-neutral-500 font-bold">#aws</button><button class="text-neutral-500 font-bold">#github</button></div><h1 class="text-3xl sm:text-4xl font-bold mb-2 sm:mb-4 mt-6 sm:mt-10">[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기</h1><div class="flex py-2 md:py-3 pl-1 text-neutral-500"><small class="">March 3, 2023<!-- -->에 작성</small></div></div><article class="max-w-none prose prose-neutral sm:prose-h1:text-[2.5rem] sm:prose-h2:text-[2rem] sm:prose-h3:text-2xl sm:prose-h4:text-xl"><h2>Overview</h2>
<p><img src="/github-aws-ci-cd-0.png" alt=""/></p>
<p>서버 배포는 다음 과정을 거쳐 이루어진다.</p>
<ol>
<li>레포지토리의 <code>main</code> 브랜치에 푸시하면 GitHub Action이 실행</li>
<li>GitHub Actions 실행<!-- -->
<ol>
<li>서버를 빌드</li>
<li>OpenID Connect로 AWS 인증</li>
<li>빌드된 파일을 AWS S3에 업로드</li>
<li>업로드가 완료되면 AWS CodeDeploy를 실행</li>
</ol>
</li>
<li>AWS CodeDeploy가 S3에 업로드된 zip 파일을 미리 정의해둔 EC2 인스턴스에 업로드</li>
<li>CodeDeploy가 소스의 설정파일(appspec.yml)에 따라 스크립트를 실행하여 서버를 EC2 인스턴스에서 실행시킴</li>
</ol>
<h2>GitHub Actions</h2>
<p>GitHub Actions는 깃 레포지토리에 <code>.github/workflow</code> 디렉터리를 만들고 <code>yaml</code> 확장자 파일을 만들어서 구성할 수 있다. <code>main</code> 브랜치에 푸시되면 자동으로 서버를 빌드해서 AWS EC2에 배포하는 다음 파일을 보면서 과정을 살펴보자.</p>
<h3><code>yaml</code> 파일</h3>
<pre style="display:block;overflow-x:auto;background:#2d2d2d;color:#cccccc;padding:0.5em"><code class="language-yaml"># [1]
name: build and deploy a spring boot server application

# [2]
on:
  push:
    branches:
      - main

# [3]
env:
  applicationfolder: backend/gfi
  AWS_REGION: # AWS 리전. ex. ap-north-east-2
  S3_BUCKET: # 빌드 파일을 업로드할 S3 버킷 이름
  CODE_DEPLOY_APP_NAME: # CodeDeploy에 설정한 앱 이름
  CODE_DEPLOY_GROUP_NAME: # CodeDeploy에 설정한 그룹 이름

#[4]
jobs:
  # [5]
  build:
    name: Build and Package
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.applicationfolder }}

    # OIDC에 쓰이는 ID 토큰 발급을 위해 정의
    permissions:
      id-token: write
      contents: read

    steps:
	  # [5-1]
      - uses: actions/checkout@v3

	  # [5-2]
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: &#x27;17&#x27;
          distribution: &#x27;temurin&#x27;

	  # [5-3]
      - name: Grant execute permission to gradlew
        run: chmod +x ./gradlew
        shell: bash

	  # [5-4]
      - name: Execute Gradle build
        run: ./gradlew build

	  # [5-5] OIDC
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

	  # [5-6]
      - name: Create a .env file
        run: |
          echo &quot;PORT=${{ vars.SERVER_PORT }}&quot; &gt;&gt; .env

	  # [5-7]
      - name: Make zip file
        run: zip -r $GITHUB_SHA.zip ./
        shell: bash

      - name: Upload Artifact to s3
        run: aws s3 cp $GITHUB_SHA.zip s3://${{ env.S3_BUCKET }}/

  # [6]
  deploy:
    needs: build
    runs-on: ubuntu-latest

    # OIDC에 쓰이는 ID 토큰 발급을 위해 정의
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v2

      - uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
      - run: |
          aws deploy create-deployment \
            --application-name ${{ env.CODE_DEPLOY_APP_NAME }} \
            --deployment-group-name ${{ env.CODE_DEPLOY_GROUP_NAME }} \
            --s3-location bucket=${{ env.S3_BUCKET }},bundleType=zip,key=$GITHUB_SHA.zip</code></pre>
<h3>[1] name</h3>
<p>실행될 GitHub Actions의 이름을 정의한다.</p>
<h3>[2] on</h3>
<p><code>main</code> 브랜치에 푸시된 경우에만 GitHub Actions가 실행되도록 한다.</p>
<h3>[3] env</h3>
<p>해당 액션에서 사용할 변수를 정의한다. 여기서 정의한 변수는 액션 내부에서 <code>${{ env.변수명 }}</code> 으로 사용할 수 있다.</p>
<p>만약 여러 액션에서 사용할 변수를 공통적으로 정의하고 싶다면, GitHub 레포의 설정에 들어가서 Repository variable을 설정하면 <code>${{ vars.변수명 }}</code> 으로 액션 내부에서 가져올 수 있다 (다만 이 변수는 외부에 공개될 수 있으므로, 시크릿 키 같은 민감한 정보는 Secret variable로 설정해서 <code>${{ secrets.변수명 }}</code> 으로 사용하자.</p>
<h3>[4] job</h3>
<p>액션이 실행될 때 수행할 작업(<code>job</code>)들을 정의한다.</p>
<p>여기서는 서버 파일을 빌드하는 작업인 <code>build</code> 와, 해당 빌드 파일을 배포하는 <code>deploy</code> 두 개의 잡이 정의되었다. 그리고 잡들은 기본적으로 병렬적으로 실행되지만 여기서는 <code>build</code> 작업이 끝난 후에만 <code>deploy</code> 작업을 실행해야 하므로 <code>needs</code> 옵션을 설정해서 순서대로 실행되게 하였다.</p>
<p>job 내부의 순서들은 <code>step</code> 을 통해 정의한다.</p>
<h3>[5] job: build</h3>
<p>build 잡은 ubuntu 환경에서 실행(<code>runs-on</code>)하고, 변수에 설정해둔 폴더를(<code>working-directory</code>) 현재 디렉터리로 설정한다.</p>
<h4>5-1</h4>
<p>가상머신에 해당 레포를 가져온다.</p>
<h4>5-2</h4>
<p>Spring 서버 빌드를 위해 JDK를 설치한다.</p>
<h4>5-3, 5-4</h4>
<p>Gradlew로 빌드 할 수 있도록 실행권한을 부여하고, 서버를 빌드한다.</p>
<h4>5-5</h4>
<p>빌드된 서버를 AWS에 업로드하기 위해서는 업로드할 AWS 계정에 대한 인증이 필요하다.</p>
<p>이전까지는 깃헙 액션을 이용하는 IAM 유저를 생성한 후에 AWS 액세스 키를 발급해서 인증하는 아래와 같은 방식이 많았지만,</p>
<pre style="display:block;overflow-x:auto;background:#2d2d2d;color:#cccccc;padding:0.5em"><code class="language-yaml">uses: aws-actions/configure-aws-credentials@v1
with:
  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  aws-region: ${{ secrets.AWS_REGION }}</code></pre>
<p><a href="https://github.com/aws-actions/configure-aws-credentials">https://github.com/aws-actions/configure-aws-credentials</a> 의 리드미를 보면, <a href="https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services">GitHub&#x27;s OIDC provider</a> 를 이용해 인증하는 방식을 추천하고 있으므로 여기서는 OpenID Connect를 통해 인증하는 방식을 사용했다.</p>
<p>이 방식을 사용하면 1. 키를 주기적으로 재발급하거나 2. 프로젝트마다 키를 새로 발급하는 귀찮은 과정을 생략할 수 있다.</p>
<h4>OIDC 셋업하기</h4>
<p><strong>1) 자격 증명 공급자 추가</strong></p>
<p>이 방식을 사용하려면 AWS의 IAM 유저 콘솔에 들어가서, 공급자 URL은 <code>https://token.actions.githubusercontent.com</code>, 대상은 <code>http://sts.amazonaws.com</code> 으로 설정한 후 ‘공급자 추가&#x27;를 누른다.</p>
<p><img src="/github-aws-ci-cd-1.png" alt=""/></p>
<p><strong>2) 역할 및 신뢰 관계 설정</strong></p>
<p>GitHub Actions에서 AWS의 S3 버킷과 CodeDeploy에 접근할 수 있어야 하므로 권한에 <code>AmazonS3FullAccess</code> 와 <code>AWSCodeDeployFullAccess</code> 권한을 주고, <strong>신뢰 관계</strong>를 다음처럼 설정하면 OIDC 를 위한 역할 생성이 완료된다.</p>
<pre style="display:block;overflow-x:auto;background:#2d2d2d;color:#cccccc;padding:0.5em"><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
      {
          &quot;Effect&quot;: &quot;Allow&quot;,
          &quot;Principal&quot;: {
              &quot;Federated&quot;: // 아까 발급한 자격 증명 공급자의 ARN을 입력한다. ex. &quot;arn:aws:iam::0123456789:oidc-provider/token.actions.githubusercontent.com&quot;
          },
          &quot;Action&quot;: &quot;sts:AssumeRoleWithWebIdentity&quot;,
          &quot;Condition&quot;: {
              &quot;StringEquals&quot;: {
                  &quot;token.actions.githubusercontent.com:aud&quot;: &quot;sts.amazonaws.com&quot;
              },
              &quot;StringLike&quot;: {
                  &quot;token.actions.githubusercontent.com:sub&quot;: // 접근할 유저, 레포, 브랜치 등을 정의한다. ex. &quot;repo:ORG_OR_USER_NAME/REPOSITORY&quot;
              }
          }
      }
  ]
}</code></pre>
<p><strong>3) 레포에 해당 역할을 시크릿 변수로 정의</strong></p>
<p>생성한 역할(Role)의 ARN을 해당 레포에 <code>AWS_ROLE_TO_ASSUME</code> 라는 이름을 가진 시크릿 키로 설정한다.</p>
<h4>5-6</h4>
<p>AWS 인증이 완료되면 서버를 띄울 때 정의할 환경 변수가 담긴 파일을 생성한다. 깃에 올라가면 안되는 민감한 정보나 깃에 올라갈 필요가 없는 변수들을 서버에 전달하기 위해 사용한다. <code>.env</code> 파일은 KEY=VALUE 가 여러 줄인 형식으로 정의되는데, 이 형식은 linux에서 <code>cat .env | xargs</code> 명령어를 통해 바로 시스템 변수로 만들 수 있으며 Spring 에서는 설정파일인 <code>application.yaml</code> 에서 시스템 변수를 바로 받을 수 있다.</p>
<h4>5-7</h4>
<p>이제 서버에 띄울 파일들을 <code>zip</code> 으로 압축하고 aws cli 명령어를 통해 s3 버킷에 올린다. <code>zip</code> 파일의 이름은 쉬운 구분을 위해 깃헙 커밋 ID(<code>$GITHUB_SHA</code>)로 정의하였다.</p>
<h3>[6] job: deploy</h3>
<p>앞선 <code>build</code> job이 성공적으로 완료되면 이 작업이 실행된다.</p>
<p>aws cli 명령어인 <code>aws deploy code-deployment</code> 명령어를 통해 CodeDeploy가 실행되도록 요청한다.</p>
<p>이 작업이 성공적으로 완료되기 위해서는 CodeDeploy에 서버 배포를 위한 CodeDeploy Group과 CodeDeploy App을 미리 만들어두어야 한다.</p>
<h4></h4></article><div><hr class="border-t border-neutral-300 my-8 sm:my-16"/><section></section></div></div></main><footer class="font-title py-4 sm:py-8 flex flex-col items-center text-neutral-600"><div class="flex flex-row my-2"><div class="flex items-center py-1"><a class="m-2 " href="https://github.com/100paperkite"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.976 0A7.977 7.977 0 0 0 0 7.976c0 3.522 2.3 6.507 5.431 7.584.392.049.538-.196.538-.392v-1.37c-2.201.49-2.69-1.076-2.69-1.076-.343-.93-.881-1.175-.881-1.175-.734-.489.048-.489.048-.489.783.049 1.224.832 1.224.832.734 1.223 1.859.88 2.3.685.048-.538.293-.88.489-1.076-1.762-.196-3.621-.881-3.621-3.964 0-.88.293-1.566.832-2.153-.05-.147-.343-.978.098-2.055 0 0 .685-.196 2.201.832.636-.196 1.322-.245 2.007-.245s1.37.098 2.006.245c1.517-1.027 2.202-.832 2.202-.832.44 1.077.146 1.908.097 2.104a3.16 3.16 0 0 1 .832 2.153c0 3.083-1.86 3.719-3.62 3.915.293.244.538.733.538 1.467v2.202c0 .196.146.44.538.392A7.984 7.984 0 0 0 16 7.976C15.951 3.572 12.38 0 7.976 0z"></path></svg></a><a class="m-2" href="mailto:100.paperkite@gmail.com"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5l.5-.5h13l.5.5v9l-.5.5h-13l-.5-.5v-9zm1 1.035V12h12V4.536L8.31 8.9H7.7L2 4.535zM13.03 4H2.97L8 7.869 13.03 4z"></path></svg></a></div></div><span class="text-sm text-neutral-500">100paperkite<!-- --> © <!-- -->2023</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"[GitHub Actions, AWS로 CI/CD 구축하기] - 1. GitHub Actions 구성하기","description":null,"uploaded":"2023-03-03T09:41:29.368Z","updated":null,"tags":["ci/cd","aws","github"],"draft":false},"slug":"github-aws-ci-cd","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      img: \"img\",\n      ol: \"ol\",\n      li: \"li\",\n      code: \"code\",\n      h3: \"h3\",\n      pre: \"pre\",\n      h4: \"h4\",\n      a: \"a\",\n      strong: \"strong\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"Overview\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/github-aws-ci-cd-0.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"서버 배포는 다음 과정을 거쳐 이루어진다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"레포지토리의 \", _jsx(_components.code, {\n            children: \"main\"\n          }), \" 브랜치에 푸시하면 GitHub Action이 실행\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"GitHub Actions 실행\", \"\\n\", _jsxs(_components.ol, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"서버를 빌드\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"OpenID Connect로 AWS 인증\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"빌드된 파일을 AWS S3에 업로드\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"업로드가 완료되면 AWS CodeDeploy를 실행\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"AWS CodeDeploy가 S3에 업로드된 zip 파일을 미리 정의해둔 EC2 인스턴스에 업로드\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"CodeDeploy가 소스의 설정파일(appspec.yml)에 따라 스크립트를 실행하여 서버를 EC2 인스턴스에서 실행시킴\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"GitHub Actions\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"GitHub Actions는 깃 레포지토리에 \", _jsx(_components.code, {\n          children: \".github/workflow\"\n        }), \" 디렉터리를 만들고 \", _jsx(_components.code, {\n          children: \"yaml\"\n        }), \" 확장자 파일을 만들어서 구성할 수 있다. \", _jsx(_components.code, {\n          children: \"main\"\n        }), \" 브랜치에 푸시되면 자동으로 서버를 빌드해서 AWS EC2에 배포하는 다음 파일을 보면서 과정을 살펴보자.\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [_jsx(_components.code, {\n          children: \"yaml\"\n        }), \" 파일\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-yaml\",\n          children: \"# [1]\\nname: build and deploy a spring boot server application\\n\\n# [2]\\non:\\n  push:\\n    branches:\\n      - main\\n\\n# [3]\\nenv:\\n  applicationfolder: backend/gfi\\n  AWS_REGION: # AWS 리전. ex. ap-north-east-2\\n  S3_BUCKET: # 빌드 파일을 업로드할 S3 버킷 이름\\n  CODE_DEPLOY_APP_NAME: # CodeDeploy에 설정한 앱 이름\\n  CODE_DEPLOY_GROUP_NAME: # CodeDeploy에 설정한 그룹 이름\\n\\n#[4]\\njobs:\\n  # [5]\\n  build:\\n    name: Build and Package\\n    runs-on: ubuntu-latest\\n    defaults:\\n      run:\\n        working-directory: ${{ env.applicationfolder }}\\n\\n    # OIDC에 쓰이는 ID 토큰 발급을 위해 정의\\n    permissions:\\n      id-token: write\\n      contents: read\\n\\n    steps:\\n\\t  # [5-1]\\n      - uses: actions/checkout@v3\\n\\n\\t  # [5-2]\\n      - name: Set up JDK 17\\n        uses: actions/setup-java@v3\\n        with:\\n          java-version: '17'\\n          distribution: 'temurin'\\n\\n\\t  # [5-3]\\n      - name: Grant execute permission to gradlew\\n        run: chmod +x ./gradlew\\n        shell: bash\\n\\n\\t  # [5-4]\\n      - name: Execute Gradle build\\n        run: ./gradlew build\\n\\n\\t  # [5-5] OIDC\\n      - name: Configure AWS credentials\\n        uses: aws-actions/configure-aws-credentials@v1\\n        with:\\n          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}\\n          aws-region: ${{ env.AWS_REGION }}\\n\\n\\t  # [5-6]\\n      - name: Create a .env file\\n        run: |\\n          echo \\\"PORT=${{ vars.SERVER_PORT }}\\\" \u003e\u003e .env\\n\\n\\t  # [5-7]\\n      - name: Make zip file\\n        run: zip -r $GITHUB_SHA.zip ./\\n        shell: bash\\n\\n      - name: Upload Artifact to s3\\n        run: aws s3 cp $GITHUB_SHA.zip s3://${{ env.S3_BUCKET }}/\\n\\n  # [6]\\n  deploy:\\n    needs: build\\n    runs-on: ubuntu-latest\\n\\n    # OIDC에 쓰이는 ID 토큰 발급을 위해 정의\\n    permissions:\\n      id-token: write\\n      contents: read\\n\\n    steps:\\n      - uses: actions/checkout@v2\\n\\n      - uses: aws-actions/configure-aws-credentials@v1\\n        with:\\n          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}\\n          aws-region: ${{ env.AWS_REGION }}\\n      - run: |\\n          aws deploy create-deployment \\\\\\n            --application-name ${{ env.CODE_DEPLOY_APP_NAME }} \\\\\\n            --deployment-group-name ${{ env.CODE_DEPLOY_GROUP_NAME }} \\\\\\n            --s3-location bucket=${{ env.S3_BUCKET }},bundleType=zip,key=$GITHUB_SHA.zip\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"[1] name\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"실행될 GitHub Actions의 이름을 정의한다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"[2] on\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"main\"\n        }), \" 브랜치에 푸시된 경우에만 GitHub Actions가 실행되도록 한다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"[3] env\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"해당 액션에서 사용할 변수를 정의한다. 여기서 정의한 변수는 액션 내부에서 \", _jsx(_components.code, {\n          children: \"${{ env.변수명 }}\"\n        }), \" 으로 사용할 수 있다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"만약 여러 액션에서 사용할 변수를 공통적으로 정의하고 싶다면, GitHub 레포의 설정에 들어가서 Repository variable을 설정하면 \", _jsx(_components.code, {\n          children: \"${{ vars.변수명 }}\"\n        }), \" 으로 액션 내부에서 가져올 수 있다 (다만 이 변수는 외부에 공개될 수 있으므로, 시크릿 키 같은 민감한 정보는 Secret variable로 설정해서 \", _jsx(_components.code, {\n          children: \"${{ secrets.변수명 }}\"\n        }), \" 으로 사용하자.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"[4] job\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"액션이 실행될 때 수행할 작업(\", _jsx(_components.code, {\n          children: \"job\"\n        }), \")들을 정의한다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"여기서는 서버 파일을 빌드하는 작업인 \", _jsx(_components.code, {\n          children: \"build\"\n        }), \" 와, 해당 빌드 파일을 배포하는 \", _jsx(_components.code, {\n          children: \"deploy\"\n        }), \" 두 개의 잡이 정의되었다. 그리고 잡들은 기본적으로 병렬적으로 실행되지만 여기서는 \", _jsx(_components.code, {\n          children: \"build\"\n        }), \" 작업이 끝난 후에만 \", _jsx(_components.code, {\n          children: \"deploy\"\n        }), \" 작업을 실행해야 하므로 \", _jsx(_components.code, {\n          children: \"needs\"\n        }), \" 옵션을 설정해서 순서대로 실행되게 하였다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"job 내부의 순서들은 \", _jsx(_components.code, {\n          children: \"step\"\n        }), \" 을 통해 정의한다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"[5] job: build\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"build 잡은 ubuntu 환경에서 실행(\", _jsx(_components.code, {\n          children: \"runs-on\"\n        }), \")하고, 변수에 설정해둔 폴더를(\", _jsx(_components.code, {\n          children: \"working-directory\"\n        }), \") 현재 디렉터리로 설정한다.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"5-1\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"가상머신에 해당 레포를 가져온다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"5-2\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Spring 서버 빌드를 위해 JDK를 설치한다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"5-3, 5-4\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Gradlew로 빌드 할 수 있도록 실행권한을 부여하고, 서버를 빌드한다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"5-5\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"빌드된 서버를 AWS에 업로드하기 위해서는 업로드할 AWS 계정에 대한 인증이 필요하다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이전까지는 깃헙 액션을 이용하는 IAM 유저를 생성한 후에 AWS 액세스 키를 발급해서 인증하는 아래와 같은 방식이 많았지만,\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-yaml\",\n          children: \"uses: aws-actions/configure-aws-credentials@v1\\nwith:\\n  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\\n  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\\n  aws-region: ${{ secrets.AWS_REGION }}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/aws-actions/configure-aws-credentials\",\n          children: \"https://github.com/aws-actions/configure-aws-credentials\"\n        }), \" 의 리드미를 보면, \", _jsx(_components.a, {\n          href: \"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services\",\n          children: \"GitHub's OIDC provider\"\n        }), \" 를 이용해 인증하는 방식을 추천하고 있으므로 여기서는 OpenID Connect를 통해 인증하는 방식을 사용했다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 방식을 사용하면 1. 키를 주기적으로 재발급하거나 2. 프로젝트마다 키를 새로 발급하는 귀찮은 과정을 생략할 수 있다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"OIDC 셋업하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"1) 자격 증명 공급자 추가\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이 방식을 사용하려면 AWS의 IAM 유저 콘솔에 들어가서, 공급자 URL은 \", _jsx(_components.code, {\n          children: \"https://token.actions.githubusercontent.com\"\n        }), \", 대상은 \", _jsx(_components.code, {\n          children: \"http://sts.amazonaws.com\"\n        }), \" 으로 설정한 후 ‘공급자 추가'를 누른다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/github-aws-ci-cd-1.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"2) 역할 및 신뢰 관계 설정\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"GitHub Actions에서 AWS의 S3 버킷과 CodeDeploy에 접근할 수 있어야 하므로 권한에 \", _jsx(_components.code, {\n          children: \"AmazonS3FullAccess\"\n        }), \" 와 \", _jsx(_components.code, {\n          children: \"AWSCodeDeployFullAccess\"\n        }), \" 권한을 주고, \", _jsx(_components.strong, {\n          children: \"신뢰 관계\"\n        }), \"를 다음처럼 설정하면 OIDC 를 위한 역할 생성이 완료된다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"Version\\\": \\\"2012-10-17\\\",\\n  \\\"Statement\\\": [\\n      {\\n          \\\"Effect\\\": \\\"Allow\\\",\\n          \\\"Principal\\\": {\\n              \\\"Federated\\\": // 아까 발급한 자격 증명 공급자의 ARN을 입력한다. ex. \\\"arn:aws:iam::0123456789:oidc-provider/token.actions.githubusercontent.com\\\"\\n          },\\n          \\\"Action\\\": \\\"sts:AssumeRoleWithWebIdentity\\\",\\n          \\\"Condition\\\": {\\n              \\\"StringEquals\\\": {\\n                  \\\"token.actions.githubusercontent.com:aud\\\": \\\"sts.amazonaws.com\\\"\\n              },\\n              \\\"StringLike\\\": {\\n                  \\\"token.actions.githubusercontent.com:sub\\\": // 접근할 유저, 레포, 브랜치 등을 정의한다. ex. \\\"repo:ORG_OR_USER_NAME/REPOSITORY\\\"\\n              }\\n          }\\n      }\\n  ]\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"3) 레포에 해당 역할을 시크릿 변수로 정의\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"생성한 역할(Role)의 ARN을 해당 레포에 \", _jsx(_components.code, {\n          children: \"AWS_ROLE_TO_ASSUME\"\n        }), \" 라는 이름을 가진 시크릿 키로 설정한다.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"5-6\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"AWS 인증이 완료되면 서버를 띄울 때 정의할 환경 변수가 담긴 파일을 생성한다. 깃에 올라가면 안되는 민감한 정보나 깃에 올라갈 필요가 없는 변수들을 서버에 전달하기 위해 사용한다. \", _jsx(_components.code, {\n          children: \".env\"\n        }), \" 파일은 KEY=VALUE 가 여러 줄인 형식으로 정의되는데, 이 형식은 linux에서 \", _jsx(_components.code, {\n          children: \"cat .env | xargs\"\n        }), \" 명령어를 통해 바로 시스템 변수로 만들 수 있으며 Spring 에서는 설정파일인 \", _jsx(_components.code, {\n          children: \"application.yaml\"\n        }), \" 에서 시스템 변수를 바로 받을 수 있다.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"5-7\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이제 서버에 띄울 파일들을 \", _jsx(_components.code, {\n          children: \"zip\"\n        }), \" 으로 압축하고 aws cli 명령어를 통해 s3 버킷에 올린다. \", _jsx(_components.code, {\n          children: \"zip\"\n        }), \" 파일의 이름은 쉬운 구분을 위해 깃헙 커밋 ID(\", _jsx(_components.code, {\n          children: \"$GITHUB_SHA\"\n        }), \")로 정의하였다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"[6] job: deploy\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"앞선 \", _jsx(_components.code, {\n          children: \"build\"\n        }), \" job이 성공적으로 완료되면 이 작업이 실행된다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"aws cli 명령어인 \", _jsx(_components.code, {\n          children: \"aws deploy code-deployment\"\n        }), \" 명령어를 통해 CodeDeploy가 실행되도록 요청한다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 작업이 성공적으로 완료되기 위해서는 CodeDeploy에 서버 배포를 위한 CodeDeploy Group과 CodeDeploy App을 미리 만들어두어야 한다.\"\n      }), \"\\n\", _jsx(_components.h4, {})]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"github-aws-ci-cd"},"buildId":"0xQjpLb5yay7gfVz4gblO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>