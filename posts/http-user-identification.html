<!DOCTYPE html><html lang="ko-KR"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:url" content="https://100paperkite.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko-KR"/><meta property="og:site_name" content="paperkite.log 👋"/><title>HTTP의 사용자 식별 기술 | paperkite.log 👋</title><meta name="robots" content="index,follow"/><meta name="description" content="HTTP의 사용자 식별 기술"/><meta property="og:title" content="HTTP의 사용자 식별 기술 | paperkite.log 👋"/><meta property="og:description" content="HTTP의 사용자 식별 기술"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2022-12-16","description":"HTTP의 사용자 식별 기술","mainEntityOfPage":{"@type":"WebPage","@id":"https://100paperkite.github.io/posts/http-user-identification"},"headline":"HTTP의 사용자 식별 기술","dateModified":"2022-12-16","author":{"@type":"Person","name":"100paperkite"}}</script><meta name="next-head-count" content="12"/><script id="gtag-init" strategy="afterInteractive">
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-FFSLQ27YMJ', {
                page_path: window.location.pathname,
              });
            </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FFSLQ27YMJ"></script><link rel="preload" href="/_next/static/css/569e3aced623cc70.css" as="style"/><link rel="stylesheet" href="/_next/static/css/569e3aced623cc70.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5b0629f93534aea2.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-1b1db7be3343898e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c1e739f18573092f.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-aee1a03cbb0f41ac.js" defer=""></script><script src="/_next/static/chunks/17007de1-711cf284c97b49d4.js" defer=""></script><script src="/_next/static/chunks/5386-90fb242547654fe3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e3edbe6380ae3f56.js" defer=""></script><script src="/_next/static/9qqRHveV-wV0LcvNEKSVw/_buildManifest.js" defer=""></script><script src="/_next/static/9qqRHveV-wV0LcvNEKSVw/_ssgManifest.js" defer=""></script><script src="/_next/static/9qqRHveV-wV0LcvNEKSVw/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><nav class="flex justify-between sticky top-0 z-50 space-x-4 py-2"><a class="text-neutral-800 hover:text-neutral-600 text-lg md:text-xl font-medium mx-2 md:mx-6 my-1 md:my-2 p-2 " href="/">paperkite.log 👋</a></nav><main class="max-w-screen-md px-4 w-full mx-auto flex-grow font-body"><div class="px-2 md:px-4 py-2 md:py-4"><div class="border-b border-1 mb-4 sm:mb-6 border-dashed border-neutral-300"><div class="flex items-center my-1 md:my-2 gap-x-2"><div class=" text-neutral-500 font-bold">#<!-- -->http</div></div><h1 class="text-3xl sm:text-4xl font-bold mb-2 sm:mb-4 mt-6 sm:mt-10">HTTP의 사용자 식별 기술</h1><div class="flex py-2 md:py-3 pl-1 text-neutral-500"><small class="">December 16, 2022<!-- -->에 작성</small><small class=""> · <!-- -->January 1, 1970<!-- -->에 변경됨</small></div></div><article class="max-w-none prose prose-neutral prose-sm sm:prose-base md:prose-md"><blockquote>
<p>HTTP 완벽 가이드를 읽고 정리한 글입니다.</p>
</blockquote>
<p>HTTP는 상태를 저장하지 않는 프로토콜인데 <small>(매 요청이 일회성이고 독립적이다)</small> 사용자를 식별하려면 어떻게 할까?</p>
<h2>사용자 식별 기술</h2>
<p>사용자 식별을 위해 존재하는 HTTP 헤더들은 다음과 같다.</p>
<table><thead><tr><th>헤더 이름</th><th>헤더 타입</th><th>설명</th></tr></thead><tbody><tr><td>From</td><td>요청</td><td>사용자의 이메일 주소</td></tr><tr><td>User-Agent</td><td>요청</td><td>사용자의 브라우저</td></tr><tr><td>*Referer</td><td>요청</td><td>사용자가 현재 링크를 타고 온 원래 주소</td></tr><tr><td>Authorization</td><td>요청</td><td>사용자 이름과 비밀번호</td></tr><tr><td>Client-ip</td><td>확장(요청)</td><td>클라이언트 IP 주소</td></tr><tr><td>X-Forwarded-For</td><td>확장(요청)</td><td>클라이언트 IP 주소</td></tr><tr><td>Cookie</td><td>확장(요청)</td><td>서버가 생성</td></tr></tbody></table>
<small><p>*영문법 상 Referrer이 맞지만 처음 이를 정의한 RFC에서 referer로 오타를 내버려서 이 단어로
굳어졌다.</p></small>
<ul>
<li>현재 From 헤더는 스팸 매일 등의 이슈로 잘 사용하지 않는다고 한다 - 로봇이나 스파이더는 제외</li>
<li>User-Agent는 브라우저에 따라 사용자 친화적인 콘텐츠를 보여주기 위함이다.</li>
</ul>
<h2>클라이언트 IP를 쓴다면?</h2>
<p>헤더에는 없지만, HTTP는 TCP이므로 서버에서 클라이언트의 IP를 알 수 있다.</p>
<p>하지만 다음과 같은 문제점 때문에 보통 클라이언트 IP로 사용자를 식별하진 않는다.</p>
<ul>
<li>IP ≠ 사용자이므로 사용자를 식별할 순 없다</li>
<li>대부분의 ISP는 동적으로 IP주소를 할당한다</li>
<li>사용자가 NAT 뒤에 있다면 개개인을 식별할 수 없다 (하나의 IP 주소이기 때문)</li>
<li>프락시나 게이트웨이를 사용한다면 웹서버가 아는 IP는 실제 클라이언트의 IP가 아니다.</li>
</ul>
<h2>HTTP 기본 인증</h2>
<p>HTTP가 기본적으로 지원하는 인증 방법이다. 브라우저에서 로그인 창이 띄워지고 서버로 보낼 수 있다. <small>(이 기본 인증은 패킷 헤더에 아무런 보안 없이 노출되기 때문에 누구나 알 수 있는 문제가 있다.)</small></p>
<ul>
<li>
<p><strong>WWW-Authenticate</strong> (서버가 클라이언트에게 보낼 때 쓰는 헤더)</p>
<ul>
<li>브라우저에서는 해당 헤더와 401(Unauthorized)를 받으면 알아서 로그인 창을 띄우게 되어 있다.</li>
</ul>
<!-- --> <!-- -->
<figure class="text-center pt-1 sm:pt-2 md:pt-3 relative w-full drop-shadow-xl" style="height:250px"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:absolute;top:0;left:0;bottom:0;right:0"><img alt="browser http login window" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill" class="flex" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain"/><noscript><img alt="browser http login window" src="/http-user-identification-0.png" decoding="async" data-nimg="fill" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain" class="flex" loading="lazy"/></noscript></span><div><a class="text-xs underline text-neutral-500"></a></div></figure>
</li>
<li>
<p><strong>Authorization</strong> (클라이언트가 서버에게 보낼 때 쓰는 헤더)</p>
<ul>
<li>브라우저에서 입력한 값은 고정된 길이의 값으로 변환되어 요청의 Authorization 헤더에 붙어 간다.<!-- -->
<figure class="text-center pt-1 sm:pt-2 md:pt-3 relative w-full drop-shadow-xl" style="height:200px"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:absolute;top:0;left:0;bottom:0;right:0"><img alt="http authorization request header" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill" class="flex" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain"/><noscript><img alt="http authorization request header" src="/http-user-identification-1.png" decoding="async" data-nimg="fill" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain" class="flex" loading="lazy"/></noscript></span><div><a class="text-xs underline text-neutral-500"></a></div></figure>
</li>
</ul>
</li>
</ul>
<h2>뚱뚱한 URL</h2>
<ul>
<li>사용자 식별 번호를 URL 뒤에 붙여서 추적한다.</li>
<li>사용자의 상태를 URL로 관리하는 것</li>
</ul>
<h3>단점</h3>
<ul>
<li>URL에 여러가지 정보가 붙여지기 때문에 URL이 혼란스럽다</li>
<li>URL에 개인 정보가 포함되어 있으므로 URL 공유 시 개인 정보도 노출된다.</li>
<li>URL이 달라지기 때문에 캐시되지 않는다.</li>
<li>뚱뚱한 URL이 아닌 URL로 접속하면 모든 정보를 잃어버린다. (지속적이지 않음)</li>
</ul>
<h2>쿠키 🍪 </h2>
<p>사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다. (모든 브라우저에서 지원한다)</p>
<h3>쿠키의 타입</h3>
<p>쿠키의 파기 시점에 따라 두 종류로 구분된다.</p>
<ul>
<li><strong>Session Cookie</strong> (세션 쿠키)<!-- -->
<ul>
<li>사용자가 브라우저를 닫으면 삭제된다.</li>
<li>쿠키 파라미터에 <code>Discard</code> 나 파기까지 남은 시점을 가리키는 <code>Expires</code> 혹은 <code>Max-Age</code> 파라미터가 없으면 세션 쿠키이다.</li>
</ul>
</li>
<li><strong>Persistent Cookie</strong> (지속 쿠키)<!-- -->
<ul>
<li>디스크에 저장된다.</li>
<li>사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.</li>
</ul>
</li>
</ul>
<h3>쿠키는 어떻게 동작할까?</h3>
<ul>
<li>
<p>사용자가 웹 사이트에 방문하면 웹 서버는 사용자에게 Set-Cookie 응답 헤더로 사용자에게 쿠키를 전달한다<small>(쿠키는 key=value 형태의 리스트이다)</small>.</p>
</li>
<li>
<p>브라우저는 서버로부터 온 Set-Cookie 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 DB에 저장한다.</p>
</li>
<li>
<p>사용자가 미래에 같은 사이트를 방문하면, 브라우저는 이전에 서버로 부터 받은 쿠키를 Cookie 요청 헤더에 적어서 보낸다.</p>
<ul>
<li>구글 크롬에서 저장한 쿠키는 <code>개발자 도구 &gt; 애플리케이션 &gt; 쿠키</code> 에서 볼 수 있다</li>
</ul>
</li>
</ul>
<h3>쿠키와 캐시</h3>
<p>쿠키 헤더를 포함한 요청에 대한 응답은, 개인 정보가 포함되어 있을 것이므로 캐시되면 안된다.</p>
<p>이런 경우 해당 문서에 Cache관련 헤더를 추가하거나 파기 시간이 0인 쿠키 헤더를 설정해서 매번 재검사하게 해야 한다.</p>
<h2>참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/15381085">HTTP 완벽 가이드</a></li>
</ul></article><div><hr class="border-t border-neutral-300 my-8 sm:my-16"/><section></section></div></div></main><footer class="font-title py-4 sm:py-8 flex flex-col items-center text-neutral-600"><div class="flex flex-row my-2"><div class="flex items-center py-1"><a class="m-2 " href="https://github.com/100paperkite"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.976 0A7.977 7.977 0 0 0 0 7.976c0 3.522 2.3 6.507 5.431 7.584.392.049.538-.196.538-.392v-1.37c-2.201.49-2.69-1.076-2.69-1.076-.343-.93-.881-1.175-.881-1.175-.734-.489.048-.489.048-.489.783.049 1.224.832 1.224.832.734 1.223 1.859.88 2.3.685.048-.538.293-.88.489-1.076-1.762-.196-3.621-.881-3.621-3.964 0-.88.293-1.566.832-2.153-.05-.147-.343-.978.098-2.055 0 0 .685-.196 2.201.832.636-.196 1.322-.245 2.007-.245s1.37.098 2.006.245c1.517-1.027 2.202-.832 2.202-.832.44 1.077.146 1.908.097 2.104a3.16 3.16 0 0 1 .832 2.153c0 3.083-1.86 3.719-3.62 3.915.293.244.538.733.538 1.467v2.202c0 .196.146.44.538.392A7.984 7.984 0 0 0 16 7.976C15.951 3.572 12.38 0 7.976 0z"></path></svg></a><a class="m-2" href="mailto:100.paperkite@gmail.com"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="w-7 h-7" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5l.5-.5h13l.5.5v9l-.5.5h-13l-.5-.5v-9zm1 1.035V12h12V4.536L8.31 8.9H7.7L2 4.535zM13.03 4H2.97L8 7.869 13.03 4z"></path></svg></a></div></div><span class="text-sm text-neutral-500">100paperkite<!-- --> © <!-- -->2022</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"HTTP의 사용자 식별 기술","uploaded":"2022-12-16","updated":null,"tags":["http"],"draft":false},"slug":"http-user-identification","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      blockquote: \"blockquote\",\n      p: \"p\",\n      h2: \"h2\",\n      table: \"table\",\n      thead: \"thead\",\n      tr: \"tr\",\n      th: \"th\",\n      tbody: \"tbody\",\n      td: \"td\",\n      ul: \"ul\",\n      li: \"li\",\n      strong: \"strong\",\n      h3: \"h3\",\n      code: \"code\",\n      a: \"a\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"HTTP 완벽 가이드를 읽고 정리한 글입니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"HTTP는 상태를 저장하지 않는 프로토콜인데 \", _jsx(\"small\", {\n          children: \"(매 요청이 일회성이고 독립적이다)\"\n        }), \" 사용자를 식별하려면 어떻게 할까?\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"사용자 식별 기술\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"사용자 식별을 위해 존재하는 HTTP 헤더들은 다음과 같다.\"\n      }), \"\\n\", _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"헤더 이름\"\n            }), _jsx(_components.th, {\n              children: \"헤더 타입\"\n            }), _jsx(_components.th, {\n              children: \"설명\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"From\"\n            }), _jsx(_components.td, {\n              children: \"요청\"\n            }), _jsx(_components.td, {\n              children: \"사용자의 이메일 주소\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"User-Agent\"\n            }), _jsx(_components.td, {\n              children: \"요청\"\n            }), _jsx(_components.td, {\n              children: \"사용자의 브라우저\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"*Referer\"\n            }), _jsx(_components.td, {\n              children: \"요청\"\n            }), _jsx(_components.td, {\n              children: \"사용자가 현재 링크를 타고 온 원래 주소\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"Authorization\"\n            }), _jsx(_components.td, {\n              children: \"요청\"\n            }), _jsx(_components.td, {\n              children: \"사용자 이름과 비밀번호\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"Client-ip\"\n            }), _jsx(_components.td, {\n              children: \"확장(요청)\"\n            }), _jsx(_components.td, {\n              children: \"클라이언트 IP 주소\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"X-Forwarded-For\"\n            }), _jsx(_components.td, {\n              children: \"확장(요청)\"\n            }), _jsx(_components.td, {\n              children: \"클라이언트 IP 주소\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"Cookie\"\n            }), _jsx(_components.td, {\n              children: \"확장(요청)\"\n            }), _jsx(_components.td, {\n              children: \"서버가 생성\"\n            })]\n          })]\n        })]\n      }), \"\\n\", _jsx(\"small\", {\n        children: _jsx(_components.p, {\n          children: \"*영문법 상 Referrer이 맞지만 처음 이를 정의한 RFC에서 referer로 오타를 내버려서 이 단어로\\n굳어졌다.\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"현재 From 헤더는 스팸 매일 등의 이슈로 잘 사용하지 않는다고 한다 - 로봇이나 스파이더는 제외\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"User-Agent는 브라우저에 따라 사용자 친화적인 콘텐츠를 보여주기 위함이다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"클라이언트 IP를 쓴다면?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"헤더에는 없지만, HTTP는 TCP이므로 서버에서 클라이언트의 IP를 알 수 있다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하지만 다음과 같은 문제점 때문에 보통 클라이언트 IP로 사용자를 식별하진 않는다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"IP ≠ 사용자이므로 사용자를 식별할 순 없다\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"대부분의 ISP는 동적으로 IP주소를 할당한다\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"사용자가 NAT 뒤에 있다면 개개인을 식별할 수 없다 (하나의 IP 주소이기 때문)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프락시나 게이트웨이를 사용한다면 웹서버가 아는 IP는 실제 클라이언트의 IP가 아니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"HTTP 기본 인증\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"HTTP가 기본적으로 지원하는 인증 방법이다. 브라우저에서 로그인 창이 띄워지고 서버로 보낼 수 있다. \", _jsx(\"small\", {\n          children: \"(이 기본 인증은 패킷 헤더에 아무런 보안 없이 노출되기 때문에 누구나 알 수 있는 문제가 있다.)\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"WWW-Authenticate\"\n            }), \" (서버가 클라이언트에게 보낼 때 쓰는 헤더)\"]\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"브라우저에서는 해당 헤더와 401(Unauthorized)를 받으면 알아서 로그인 창을 띄우게 되어 있다.\"\n            }), \"\\n\"]\n          }), \"\\n\", ' ', \"\\n\", _jsx(Image, {\n            src: \"/http-user-identification-0.png\",\n            alt: \"browser http login window\",\n            height: \"250px\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"Authorization\"\n            }), \" (클라이언트가 서버에게 보낼 때 쓰는 헤더)\"]\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"브라우저에서 입력한 값은 고정된 길이의 값으로 변환되어 요청의 Authorization 헤더에 붙어 간다.\", \"\\n\", _jsx(Image, {\n                src: \"/http-user-identification-1.png\",\n                alt: \"http authorization request header\",\n                height: \"200px\"\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"뚱뚱한 URL\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"사용자 식별 번호를 URL 뒤에 붙여서 추적한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"사용자의 상태를 URL로 관리하는 것\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"단점\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"URL에 여러가지 정보가 붙여지기 때문에 URL이 혼란스럽다\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"URL에 개인 정보가 포함되어 있으므로 URL 공유 시 개인 정보도 노출된다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"URL이 달라지기 때문에 캐시되지 않는다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"뚱뚱한 URL이 아닌 URL로 접속하면 모든 정보를 잃어버린다. (지속적이지 않음)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"쿠키 🍪 \"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다. (모든 브라우저에서 지원한다)\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"쿠키의 타입\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"쿠키의 파기 시점에 따라 두 종류로 구분된다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Session Cookie\"\n          }), \" (세션 쿠키)\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"사용자가 브라우저를 닫으면 삭제된다.\"\n            }), \"\\n\", _jsxs(_components.li, {\n              children: [\"쿠키 파라미터에 \", _jsx(_components.code, {\n                children: \"Discard\"\n              }), \" 나 파기까지 남은 시점을 가리키는 \", _jsx(_components.code, {\n                children: \"Expires\"\n              }), \" 혹은 \", _jsx(_components.code, {\n                children: \"Max-Age\"\n              }), \" 파라미터가 없으면 세션 쿠키이다.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"Persistent Cookie\"\n          }), \" (지속 쿠키)\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"디스크에 저장된다.\"\n            }), \"\\n\", _jsx(_components.li, {\n              children: \"사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"쿠키는 어떻게 동작할까?\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"사용자가 웹 사이트에 방문하면 웹 서버는 사용자에게 Set-Cookie 응답 헤더로 사용자에게 쿠키를 전달한다\", _jsx(\"small\", {\n              children: \"(쿠키는 key=value 형태의 리스트이다)\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"브라우저는 서버로부터 온 Set-Cookie 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 DB에 저장한다.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"사용자가 미래에 같은 사이트를 방문하면, 브라우저는 이전에 서버로 부터 받은 쿠키를 Cookie 요청 헤더에 적어서 보낸다.\"\n          }), \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsxs(_components.li, {\n              children: [\"구글 크롬에서 저장한 쿠키는 \", _jsx(_components.code, {\n                children: \"개발자 도구 \u003e 애플리케이션 \u003e 쿠키\"\n              }), \" 에서 볼 수 있다\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"쿠키와 캐시\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"쿠키 헤더를 포함한 요청에 대한 응답은, 개인 정보가 포함되어 있을 것이므로 캐시되면 안된다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 경우 해당 문서에 Cache관련 헤더를 추가하거나 파기 시간이 0인 쿠키 헤더를 설정해서 매번 재검사하게 해야 한다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"참고\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"http://www.yes24.com/Product/Goods/15381085\",\n            children: \"HTTP 완벽 가이드\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"http-user-identification"},"buildId":"9qqRHveV-wV0LcvNEKSVw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>